(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
Print["Dynamica (Version 1.0.11 - 5/8/2021), Copyright(c) 1993-2021 Randall D. Beer. All rights reserved."]


(* ::Input::Initialization:: *)
Print["THIS SOFTWARE IS DISTRIBUTED 'AS IS'. NO WARRANTY OF ANY KIND IS EXPRESSED OR IMPLIED."]


(* ::Input::Initialization:: *)
BeginPackage["Dynamica`"]


(* ::Input::Initialization:: *)
$EqualityTolerance::Usage="";
$DynamicaShortFormat::Usage="";
$DynamicaFullSimplify::Usage="";
$DynamicaSymbolicThreshold::Usage="";
$Trajectories::Usage="";
$PhasePortraitEPs::Usage="";
$BifurcationDiagramBPs::Usage="";
$ParameterChartCodim2BPs::Usage="";


(* ::Input::Initialization:: *)
DynamicalSystem::usage="";
LimitSet::usage="";
EquilibriumPoint::usage="";
LimitCycle::usage="";
EquilibriumBranch::usage="";
BifurcationPoint::usage="";
BifurcationBranch::usage="";
Codim2Point::usage="";


(* ::Input::Initialization:: *)
DSParameterValue::usage="";
LSDynamicalSystem::usage="";
LSType::usage="";
LSPoint::usage="";
LSStability::usage="";
EPType::usage="";
EPEigenvalues::usage="";
EPEigenvectors::usage="";
LCPeriod::usage="";
LCFloquetMultipliers::usage="";
LCTrajectory::usage="";


(* ::Input::Initialization:: *)
t::usage="";
From::usage="";
Boundary::usage="";
Nonhyperbolic::usage="";
Stable::usage="";
Saddle::usage="";
Unstable::usage="";
Node::usage="";
Spiral::usage="";
Mixed::usage="";
(* Fold::usage="";*)
Branch::usage="";
Hopf::usage="";
NeutralSaddle::usage="";
Cusp::usage="";
BogdanovTakens::usage="";
GeneralizedHopf::usage="";
FoldHopf::usage="";
HopfHopf::usage="";


(* ::Input::Initialization:: *)
SamplePoints::usage="";
TrajectoryPlotMode::usage="";
Arrows::usage="";
FlowPlotMode::usage="";
Tries::usage="";
LimitSets::usage="";
SaddleManifolds::usage="";
SaddleManifoldInitialStep::usage="";
SaddleManifoldDuration::usage="";
SaddleManifoldPlotPoints::usage="";
SaddleManifoldArrows::usage="";
NullManifolds::usage="";
StateSpace::usage="";
EquilibriumPointStyle::usage="";
SaddleManifoldStyle::usage="";
NullManifold2Style::usage="";
NullManifold2PlotPoints::usage="";
NullManifold3PlotPoints::usage="";
NullManifoldOpacity::usage="";
MinStepSize::usage="";
SolveForInitialPointFixing::usage="";
SwitchBranches::usage="";
TestExpressions::usage="";
VerificationExpressions::usage="";
NeutralSaddles::usage="";
InteriorPoints::usage="";
InteriorGrid::usage="";
ParameterStateSpace::usage="";
EquilibriumBranchStyle::usage="";
BifurcationPointStyle::usage="";
LimitCycleBranches::usage="";
StateVariables::usage="";
BifurcationData::usage="";
ParameterSpace::usage="";
BifurcationBranchStyle::usage="";Codim2PointStyle::usage="";


(* ::Input::Initialization:: *)
DynamicalSystem::usage="";
DSSetParameters::usage="";
DSClearParameters::usage="";
TransformDynamicalSystem::usage="";
DisplayVectorField::usage="";
Trajectory::usage="";
DisplayTrajectories::usage="";
DisplayFlow::usage="";
EquilibriumPoints::usage="";
FindLimitCycle::usage="";
DisplayPhasePortrait::usage = "";
FollowSolutionBranch::usage="";
FollowEquilibriumBranch::usage = "";
EquilibriumBranches::usage="";
FollowLimitCycleBranch::usage="";
DisplayBifurcationDiagram::usage= "";
FollowBifurcationBranch::usage = "";
BifurcationBranches::usage="";
DisplayParameterChart::usage = "";
PhasePortraitExplorer::usage="";


(* ::Input::Initialization:: *)
Begin["`Private`"]


(* ::Input::Initialization:: *)
$EqualityTolerance=N[10^-5];


(* ::Input::Initialization:: *)
$DynamicaShortFormat=True;


(* ::Input::Initialization:: *)
$DynamicaFullSimplify=False;


(* ::Input::Initialization:: *)
$DynamicaSymbolicThreshold=5;


(* ::Input::Initialization:: *)
MyChop[x_]:=Chop[x,$EqualityTolerance/100]


(* ::Input::Initialization:: *)
TildeTilde[x_,y_]:=Abs[x-y]<=$EqualityTolerance


(* ::Input::Initialization:: *)
EqualPoint[p1_,p2_] :=(Length[p1]==Length[p2])&& Apply[And,Thread[p1\[TildeTilde]p2]]


(* ::Input::Initialization:: *)
CircleDot[x_,y_]:=
Module[{n,l,Elt},
n=Length[x];
l=Flatten[Table[{p,q},{p,2,n},{q,1,p-1}],1];
Elt[{p_,q_},{r_,s_}]:=1/2 (Det[({
 {x[[p,r]], x[[p,s]]},
 {y[[q,r]], y[[q,s]]}
})]+Det[({
 {y[[p,r]], y[[p,s]]},
 {x[[q,r]], x[[q,s]]}
})]);
Outer[Elt,l,l,1]
]/;(MatrixQ[x]&&MatrixQ[y]&&Apply[Equal,Join[Dimensions[x],Dimensions[y]]])


(* ::Input::Initialization:: *)
ED[p1_,p2_]:=With[{d=p1-p2},Sqrt[Plus@@(d^2)]]


(* ::Input::Initialization:: *)
ListArcLength[pts_]:=Plus@@Map[ED[#[[1]],#[[2]]]&,Partition[pts,2,1]]


(* ::Input::Initialization:: *)
JacobianMatrix[fns_,vars_]:=Outer[D,fns,vars]


(* ::Input::Initialization:: *)
NEigenvalues[M_?MatrixQ]:=Eigenvalues[M]/;EveryQ[NumericQ,Flatten[M]]


(* ::Input::Initialization:: *)
PureImaginaryQ[x_]:=!Im[x]\[TildeTilde]0&&Re[x]\[TildeTilde]0


(* ::Input::Initialization:: *)
MyNullSpace[M_]:=NullSpace[MyChop[M],Tolerance->$EqualityTolerance/100]


(* ::Input::Initialization:: *)
AppendRows[l__?MatrixQ]:=Apply[Join,Transpose[{l}],{1}]


(* ::Input::Initialization:: *)
SomeQ[pred_,l_List]:=Length[Select[l,pred]]>0


(* ::Input::Initialization:: *)
EveryQ[pred_,l_List]:=Length[Select[l,pred]]==Length[l]


(* ::Input::Initialization:: *)
InBounds[Xs_,XMins_,XMaxs_]:=Apply[And,Thread[XMins<=Xs<=XMaxs]];


(* ::Input::Initialization:: *)
(*PlotGraphicsPoints[g_]:=Select[Flatten[g\[LeftDoubleBracket]1\[RightDoubleBracket]],(Head[#]\[Equal]Line)&]\[LeftDoubleBracket]1,1\[RightDoubleBracket]*)
PlotGraphicsPoints[g_]:=Cases[g,Line[_],\[Infinity]][[1,1]]


(* ::Input::Initialization:: *)
PlotGraphics3DPoints[g_]:=
Cases[g,Line[_],\[Infinity]][[1,1]]


(* ::Input::Initialization:: *)
InterpolatingFunctionDomain[IntFunc_]:=IntFunc[Domain]


(* ::Input::Initialization:: *)
Arrow3D[{s_,e_}]:=
Module[{ar=0.015,al=0.04,sides=10,v,p,ss,g},
v=(e-s)/Norm[e-s];
p={v[[2]],-v[[1]],0}/Norm[{v[[2]],-v[[1]],0}];
ss=al v;
For[i=0;g={EdgeForm[]},i<sides,i++,
p1=RotationMatrix[i 2\[Pi]/sides,v] . p;
p2=RotationMatrix[(i+1)2\[Pi]/sides,v] . p;
AppendTo[g,Polygon[{e,Scaled[ar p1-ss,e],Scaled[ar p2-ss,e]}]]];
g
]


(* ::Input::Initialization:: *)
CompiledFunctionSource[CFunc_CompiledFunction]:=CFunc[[7,2]]


(* ::Input::Initialization:: *)
LinkedListToList[LL_]:=
Flatten[LL,\[Infinity],LinkedList]/.LinkedList->List


(* ::Input::Initialization:: *)
RealifyRuleList[L_]:=Thread[Map[(#[[1]])&,L]->Map[(Re[#[[2]]])&,L]]


(* ::Input::Initialization:: *)
QuasiRandom[n_,Mins_,Maxs_]:=
Module[{i=1,Syms=Table[Unique[],{Length[Mins]}],Pts=Table[0,{n+1}]},
NIntegrate[(Pts[[i++]]=Syms;1),Evaluate[Sequence@@Thread[{Syms,Mins,Maxs}]],MaxPoints->n,Method->QuasiMonteCarlo];
Drop[Pts,1]]


(* ::Input::Initialization:: *)
ToNumber[s_String]:=
Block[{$Messages,$MessageList={}},
Module[{v},
v=N[ToExpression[s]];
If[Length[$MessageList]>0||!NumericQ[v],$BADNUMBER,v]]]


(* ::Input::Initialization:: *)
SymbolQ[s_]:=AtomQ[s]&&!NumericQ[s]


(* ::Input::Initialization:: *)
CheckOptions[fn_,opts___]:=
Module[{BadOpts=Complement[First/@{opts},First/@Options[fn]]},
If[Length[BadOpts]>0,
Message[MessageName[fn,"optx"],BadOpts,{opts}]]]


(* ::Input::Initialization:: *)
MyPosition[x_,L_List]:=
First[First[Position[L,x,1]]]

MyPosition[x_,L_List,Key->Fn_]:=
First[First[Position[Fn/@L,x,1]]]


(* ::Input::Initialization:: *)
MyFindRoot[fs_,yspecs_,opts___]:=
Block[{$Messages,$MessageList={}},
Module[{root},
root=FindRoot[Evaluate[fs],Evaluate[yspecs],Evaluate[opts]];
If[Length[DeleteCases[$MessageList,HoldForm[FindRoot::precw]|HoldForm[FindRoot::bddir]]]>0||SomeQ[(!(#\[TildeTilde]0))&,Map[Im[#[[2]]]&,root] ],
$BADROOT,
RealifyRuleList[root]]]]


(* ::Input::Initialization:: *)
NDet[M_]:=Det[M]/;MatrixQ[M,NumberQ]


(* ::Input::Initialization:: *)
Format[DynamicalSystem[d_,fs_,ys_,ymins_,ymaxs_,\[Lambda]s_,\[Lambda]Mins_,\[Lambda]Maxs_,\[Lambda]Substs_,___]]:=
Module[{Ps,ClearPs,SetPs,str},
SetPs=First/@\[Lambda]Substs;
ClearPs=Complement[\[Lambda]s,SetPs];
SetPs=Thread[SetPs->(SetPs/.\[Lambda]Substs)];
If[Length[fs]==1,
str="DynamicalSystem[\[LeftSkeleton]"<>ToString[Length[fs]]<>" ODE\[RightSkeleton],"<>ToString[ys,StandardForm]<>",",
str="DynamicalSystem[\[LeftSkeleton]"<>ToString[Length[fs]]<>" ODEs\[RightSkeleton],"<>ToString[ys,StandardForm]<>","];
Which[
Length[\[Lambda]Substs]==0,str=str<>ToString[\[Lambda]s,StandardForm],
Length[\[Lambda]Substs]==Length[\[Lambda]s],str=str<>ToString[\[Lambda]Substs,StandardForm],
True,str=str<>ToString[ClearPs,StandardForm]<>","<>ToString[SetPs,StandardForm]];
str<>"]"]/;$DynamicaShortFormat


(* ::Input::Initialization:: *)
DSDimension[ds_DynamicalSystem]:=ds[[1]]
DSFunctions[ds_DynamicalSystem]:=ds[[2]]
DSStateVariables[ds_DynamicalSystem]:=ds[[3]]
DSYMins[ds_DynamicalSystem]:=ds[[4]]
DSYMaxs[ds_DynamicalSystem]:=ds[[5]]
DSParameters[ds_DynamicalSystem]:=ds[[6]]
DS\[Lambda]Mins[ds_DynamicalSystem]:=ds[[7]]
DS\[Lambda]Maxs[ds_DynamicalSystem]:=ds[[8]]
DSParameterSubsts[ds_DynamicalSystem]:=ds[[9]]
DSJacobian[ds_DynamicalSystem]:=ds[[10]]
DS\[Phi]1[ds_DynamicalSystem]:=ds[[11]]
DS\[Phi]2[ds_DynamicalSystem]:=ds[[12]]


(* ::Input::Initialization:: *)
Format[LimitSet[ds_DynamicalSystem,EquilibriumPoint,pt_List,stability_,type_,___]]:=
"EquilibriumPoint["<>ToString[stability]<>","<>ToString[type]<>","<>ToString[pt,StandardForm]<>"]"/;$DynamicaShortFormat


(* ::Input::Initialization:: *)
LSDynamicalSystem[ls_LimitSet]:=ls[[1]]
LSType[ls_LimitSet]:=ls[[2]]
LSPoint[ls_LimitSet]:=ls[[3]]
LSStability[ls_LimitSet]:=ls[[4]]


(* ::Input::Initialization:: *)
EPType[ep_LimitSet]:=ep[[5]]/;LSType[ep]===EquilibriumPoint
EPEigenvalues[ep_LimitSet]:=ep[[6]]/;LSType[ep]===EquilibriumPoint
EPEigenvectors[ep_LimitSet]:=ep[[7]]/;LSType[ep]===EquilibriumPoint


(* ::Input::Initialization:: *)
Format[LimitSet[ds_DynamicalSystem,LimitCycle,pt_List,stability_,period_,___]]:=
"LimitCycle["<>ToString[stability]<>","<>ToString[period]<>","<>ToString[pt,StandardForm]<>"]"/;$DynamicaShortFormat


(* ::Input::Initialization:: *)
LCPeriod[lc_LimitSet]:=lc[[5]]/;LSType[lc]===LimitCycle
LCFloquetMultipliers[lc_LimitSet]:=lc[[6]]/;LSType[lc]===LimitCycle
LCTrajectory[lc_LimitSet]:=lc[[7]]/;LSType[lc]===LimitCycle


(* ::Input::Initialization:: *)
Format[EquilibriumBranch[ds_,type_,\[Lambda]_,pts_]]:=
"EquilibriumBranch["<>ToString[type]<>","<>ToString[\[Lambda],StandardForm]<>",{"<>ToString[First[pts],StandardForm]<>",...,"<>ToString[Last[pts],StandardForm]<>"}]"/;$DynamicaShortFormat


(* ::Input::Initialization:: *)
EBDynamicalSystem[eb_EquilibriumBranch]:=eb[[1]]
EBType[eb_EquilibriumBranch]:=eb[[2]]
EBParameter[eb_EquilibriumBranch]:=eb[[3]]
EBPoints[eb_EquilibriumBranch]:=eb[[4]]


(* ::Input::Initialization:: *)
Format[BifurcationPoint[ds_,type_,pt_]]:=
"BifurcationPoint["<>ToString[type]<>","<>ToString[pt,StandardForm]<>","<>ToString[DSParameterSubsts[ds],StandardForm]<>"]"/;$DynamicaShortFormat


(* ::Input::Initialization:: *)
BPDynamicalSystem[bp_BifurcationPoint]:=bp[[1]]
BPType[bp_BifurcationPoint]:=bp[[2]]
BPPoint[bp_BifurcationPoint]:=bp[[3]]
BPParameterSubsts[bp_BifurcationPoint]:=DSParameterSubsts[BPDynamicalSystem[bp]]


(* ::Input::Initialization:: *)
Format[BifurcationBranch[ds_,type_,\[Lambda]s_,pts_]]:=
"BifurcationBranch["<>ToString[type]<>","<>ToString[\[Lambda]s,StandardForm]<>",{"<>ToString[First[pts],StandardForm]<>",...,"<>ToString[Last[pts],StandardForm]<>"}]"/;$DynamicaShortFormat


(* ::Input::Initialization:: *)
BBDynamicalSystem[bb_BifurcationBranch]:=bb[[1]]
BBType[bb_BifurcationBranch]:=bb[[2]]
BBParameters[bb_BifurcationBranch]:=bb[[3]]
BBPoints[bb_BifurcationBranch]:=bb[[4]]


(* ::Input::Initialization:: *)
Format[Codim2Point[ds_,type_,pt_]]:=
"Codim2Point["<>ToString[type]<>","<>ToString[pt,StandardForm]<>","<>ToString[DSParameterSubsts[ds],StandardForm]<>"]"/;$DynamicaShortFormat


(* ::Input::Initialization:: *)
C2PDynamicalSystem[c2p_Codim2Point]:=c2p[[1]]
C2PType[c2p_Codim2Point]:=c2p[[2]]
C2PPoint[c2p_Codim2Point]:=c2p[[3]]
C2PParameterSubsts[c2p_Codim2Point]:=DSParameterSubsts[C2PDynamicalSystem[c2p]]


(* ::Input::Initialization:: *)
DynamicalSystem[fs_List,yys_List]:=DynamicalSystem[fs,yys,{}]


(* ::Input::Initialization:: *)
DynamicalSystem[fs_List,yys_List,\[Lambda]\[Lambda]s_List]:=
Module[{l,ys,ymins,ymaxs,\[Lambda]s,\[Lambda]mins,\[Lambda]maxs,J,\[Phi]1,\[Phi]2},
ys=Map[#[[1]]&,yys];
l=Select[ys,!SymbolQ[#]&];
If[!l==={},
Print["Nonsymbolic state variables: ",l];Return[]];
If[Length[fs]!=Length[yys],
Print["Inconsistent dimension: DynamicalSystem[",fs,",",yys,",",\[Lambda]\[Lambda]s,"]"];Return[]];
ymins=Map[#[[2]]&,yys];
ymaxs=Map[#[[3]]&,yys];
\[Lambda]s=Map[#[[1]]&,\[Lambda]\[Lambda]s];
l=Select[\[Lambda]s,!SymbolQ[#]&];
If[!l==={},
Print["Nonsymbolic parameters: ",l];Return[]];
\[Lambda]mins=Map[#[[2]]&,\[Lambda]\[Lambda]s];
\[Lambda]maxs=Map[#[[3]]&,\[Lambda]\[Lambda]s];
n=Length[ys];
J=JacobianMatrix[fs,ys];
If[n<=$DynamicaSymbolicThreshold,
\[Phi]1=Det[J];\[Phi]2=If[n>1,Det[2 J\[CircleDot]IdentityMatrix[n]],0],
\[Phi]1=\[Phi]2=Numerical];
If[$DynamicaFullSimplify,
J=FullSimplify[J];
\[Phi]1=FullSimplify[\[Phi]1];
\[Phi]2=FullSimplify[\[Phi]2]];
DynamicalSystem[n,fs,ys,ymins,ymaxs,\[Lambda]s,\[Lambda]mins,\[Lambda]maxs,{},J,\[Phi]1,\[Phi]2]
]


(* ::Input::Initialization:: *)
DSFreeParameters[ds_DynamicalSystem]:=
Module[{fns=DSFunctions[ds]/.DSParameterSubsts[ds],xs},
xs=Position[fns,_?SymbolQ,Heads->False];
Complement[Extract[fns,xs],Append[DSStateVariables[ds],t]]]


(* ::Input::Initialization:: *)
DSSetParameters[ds_DynamicalSystem,PSs_?OptionQ]:=
Module[{PSubsts,Ps,NewPs,BadPs,BadVs},
If[ListQ[PSs],PSubsts=PSs,PSubsts={PSs}];
BadPs=Select[First/@PSubsts,!SymbolQ[#]&];
If[Length[BadPs]!=0,
Print["Nonsymbolic parameters: ",BadPs];Return[ds]];
BadPs=Complement[First/@PSubsts,DSParameters[ds]];
If[Length[BadPs]!=0,
Print["Invalid parameters ",BadPs," for ",ds];Return[ds]];
Ps=Union[First/@PSubsts,First/@DSParameterSubsts[ds]];
NewPs=Thread[Ps->(Ps/.Join[PSubsts,DSParameterSubsts[ds]])];
(*
NewPs=Thread[Ps\[Rule] (ReplaceRepeated[Ps,Join[PSubsts,DSParameterSubsts[ds]],MaxIterations\[Rule]1+Length[DSParameters[ds]]])];
*)
(*BadVs=Select[Last/@NewPs,!NumericQ[#]&];
If[Length[BadVs]\[NotEqual]0,
Print["Nonnumeric parameter values ",BadVs];Return[ds]];*)
DynamicalSystem[
DSDimension[ds],DSFunctions[ds],
DSStateVariables[ds],DSYMins[ds],DSYMaxs[ds],
DSParameters[ds],DS\[Lambda]Mins[ds],DS\[Lambda]Maxs[ds],NewPs,
DSJacobian[ds],DS\[Phi]1[ds],DS\[Phi]2[ds]]]


(* ::Input::Initialization:: *)
Unprotect[ReplaceAll];
ReplaceAll[ds_DynamicalSystem,rules_]:=DSSetParameters[ds,rules]
Protect[ReplaceAll];


(* ::Input::Initialization:: *)
DSClearParameters[ds_DynamicalSystem,\[Lambda]\[Lambda]s_List]:=
Module[{\[Lambda]s=\[Lambda]\[Lambda]s,BadPs},
BadPs=Complement[\[Lambda]s,DSParameters[ds]];
If[Length[BadPs]!=0,
Print["Invalid parameters ", BadPs," for ",ds];Return[ds]];
\[Lambda]s=\[Lambda]s\[Intersection]First/@DSParameterSubsts[ds];
DynamicalSystem[
DSDimension[ds],DSFunctions[ds],
DSStateVariables[ds],DSYMins[ds],DSYMaxs[ds],
DSParameters[ds],DS\[Lambda]Mins[ds],DS\[Lambda]Maxs[ds],
Delete[DSParameterSubsts[ds],Map[{MyPosition[#,DSParameterSubsts[ds],Key->First]}&,\[Lambda]s]],
DSJacobian[ds],DS\[Phi]1[ds],DS\[Phi]2[ds]]]


(* ::Input::Initialization:: *)
DSParameterValue[ds_DynamicalSystem,\[Lambda]_]:=
Module[{v},
v=\[Lambda]/.DSParameterSubsts[ds];
If[NumericQ[v],
v,
Print["Parameter ",\[Lambda]," has no value in ",ds]]]


(* ::Input::Initialization:: *)
DSParameterHasValueQ[ds_DynamicalSystem,\[Lambda]_]:=NumericQ[\[Lambda]/.DSParameterSubsts[ds]]


(* ::Input::Initialization:: *)
TransformDynamicalSystem[ds_DynamicalSystem,NewYYs_List,Trans_List]:=
Module[{t,Ys,NewYs,Fns,DTrans,NewFns,InvTrans,New\[Lambda]s},
Ys=DSStateVariables[ds];
NewYs=First/@NewYYs;
If[Length[Ys]!=Length[NewYs],
Print[Ys," and ",NewYs," must have the same dimension"];
Return[ds]];
Yts=Map[#[t]&,Ys];
Fns=DSFunctions[ds];
DTrans=Map[D[#,t]&,Trans/.Thread[Ys->Yts]];
DTrans=DTrans/.Thread[Yts->Ys];
NewFns=DTrans/.Thread[Map[#'[t]&,Ys]->Fns];
InvTrans=Flatten[Solve[Thread[NewYs==Trans],Ys,Reals]];
If[Length[InvTrans]==0,
Print["Unable to solve for inverse transformations"];
Return[ds]];
If[Length[InvTrans]!=Length[Trans],
Print["Inverse transformations are not unique"];
Return[ds]];
NewFns=NewFns/.InvTrans;
NewFns=If[$DynamicaFullSimplify,FullSimplify[NewFns],Simplify[NewFns]];
NewFns=Map[If[Head[#]===ConditionalExpression,First[#],#]&,NewFns];
New\[Lambda]s=Thread[{DSParameters[ds],DS\[Lambda]Mins[ds],DS\[Lambda]Maxs[ds]}];
DynamicalSystem[NewFns,NewYYs,New\[Lambda]s]/.DSParameterSubsts[ds]]


(* ::Input::Initialization:: *)
Options[DisplayVectorField]={Axes->Automatic,AxesLabel->Automatic,Frame->Automatic,FrameLabel->Automatic,Boxed->True,BoxRatios->{1,1,1},PlotPoints->Automatic,BoxStyle->{Thickness[0.001],GrayLevel[0.7]},Lighting->Automatic,ViewPoint->{1.2,-2.4,2},PlotRange->StateSpace,PlotRangeClipping->True,VectorStyle->Brown,VectorScale->{Automatic,Automatic,None}};


(* ::Input::Initialization:: *)
DisplayVectorField[ds_DynamicalSystem,opts___?OptionQ]:=
Module[{n=DSDimension[ds],fps=DSFreeParameters[ds],SVs=DSStateVariables[ds],fns=DSFunctions[ds]/. DSParameterSubsts[ds],Opts,VOpts,VFP2Opts,VFP3Opts,G2Opts,G3Opts,PR,PP,AX,FR,ALabels,FLabels,AR,VFG,dum},
If[!(n<=3),Print["Dimension must be \[LessEqual] 3 for DisplayVectorField"];Return[]];
If[fps=!={},Print["Too many free parameters for DisplayVectorField: ",fps];Return[{}]];
Opts=Join[{opts},Options[DisplayVectorField]];
If[n==1||n==2,Opts=Join[Opts,Options[Graphics]],Opts=Join[Opts,Options[Graphics3D]]];
VOpts=Sequence@@FilterRules[Opts,Options[DisplayVectorField]];
VFP2Opts=FilterRules[Opts,Options[VectorPlot]];
VFP3Opts=FilterRules[Opts,Options[VectorPlot3D]];
PP=PlotPoints/.Opts;
If[PP===Automatic,PP=Which[n==1,15,n==2,25,n==3,10]];
PR=PlotRange/.Opts;
If[PR===Automatic||PR===All,PR=StateSpace];
If[PR===StateSpace,PR=Thread[{DSYMins[ds],DSYMaxs[ds]}]];
If[n==1,If[ListQ[PR[[1]]],PR={PR[[1]],{-0.001,0.001}},PR={PR,{-0.001,0.001}}]];
AX=Axes/. Opts;
If[AX===Automatic,Which[n==1,AX={True,False},n==2,AX=False,n==3,AX=True]];
FR=Frame/. Opts;If[FR===Automatic,Which[n==1,FR=False,n==2,FR=True]];
ALabels=AxesLabel/. Opts;If[ALabels===Automatic,ALabels=DSStateVariables[ds]];FLabels=FrameLabel/. Opts;If[FLabels===Automatic,FLabels=DSStateVariables[ds]];AR=AspectRatio/. Opts;If[AR===Automatic,Which[n==1,AR=1/8,n==2,AR=1,True,AR=Automatic]];
VFP2Opts=Join[{PlotRange->PR,Axes->AX,AxesLabel->ALabels,Frame->FR,FrameLabel->FLabels,AspectRatio->AR},VFP2Opts];
VFP3Opts=Join[{PlotRange->PR,Axes->AX,AxesLabel->ALabels},VFP3Opts];
Which[
n==1,VectorPlot@@Join[{{fns[[1]],0},{SVs[[1]],PR[[1,1]],PR[[1,2]]},{dum,-0.00001,0.00001}},VFP2Opts],
n==2,
VectorPlot@@Join[{fns,{SVs[[1]],PR[[1,1]],PR[[1,2]]},{SVs[[2]],PR[[2,1]],PR[[2,2]]}},VFP2Opts],
n==3,VectorPlot3D@@Join[{fns,{SVs[[1]],PR[[1,1]],PR[[1,2]]},{SVs[[2]],PR[[2,1]],PR[[2,2]]},{SVs[[3]],PR[[3,1]],PR[[3,2]]}},VFP3Opts]]]



(* ::Input::Initialization:: *)
Options[Trajectory]=Options[NDSolve];


(* ::Input::Initialization:: *)
Trajectory[ds_DynamicalSystem,YIs_List,Duration_,opts___?OptionQ]:=Module[{fps,NDOpts,fns,ys,newys,eqns,neqns},fps=DSFreeParameters[ds];If[fps=!={},Print["Too many free parameters for Trajectory: ",fps];Return[{}]];CheckOptions[Trajectory,opts];NDOpts=Sequence@@FilterRules[Flatten[{opts}],Options[NDSolve]];
fns=DSFunctions[ds]/. DSParameterSubsts[ds];ys=DSStateVariables[ds];newys=(#1[t]&)/@ys;
If[!InBounds[YIs,DSYMins[ds],DSYMaxs[ds]],
Return[Table[newys[[i]]->Interpolation[{{0,YIs[[i]]},{$EqualityTolerance,YIs[[i]]}},InterpolationOrder->1][t],{i,1,Length[ys]}]]];
If[Duration>=0,
eqns=Thread[(Derivative[1][#1][t]&)/@ys==(fns/. Thread[ys->newys])],eqns=Thread[(Derivative[1][#1][t]&)/@ys==(-fns/. Thread[ys->newys])]];
Quiet[
First[NDSolve[Join[eqns,Thread[(newys/. t->0)==YIs]],newys,{t,0,Abs[Duration]},NDOpts,StoppingTest->OutOfBoundsTest[ds],MaxSteps->10000]],
{NDSolve::ndsz}]]


(* ::Input::Initialization:: *)
OutOfBoundsTest[ds_DynamicalSystem]:=\[Not]InBounds[Map[Apply[#,{t}]&,DSStateVariables[ds]],DSYMins[ds]-0.1Abs[DSYMins[ds]],DSYMaxs[ds]+0.1Abs[DSYMaxs[ds]]]


(* ::Input::Initialization:: *)
Options[TrajectorySegment]={SamplePoints->100};


(* ::Input::Initialization:: *)
TrajectorySegment[Soln_,tMax_?NumberQ,opts___?OptionQ]:=
TrajectorySegment[Soln,{0,tMax},opts]


(* ::Input::Initialization:: *)
TrajectorySegment[Soln_,{tMin_,tMax_},opts___?OptionQ]:=
Module[{SPs,d,IFRange,startT,stopT,IFs,fs,g},
CheckOptions[TrajectorySegment,opts];
SPs=SamplePoints/.{opts}/.Options[TrajectorySegment];
d=Length[Soln];
IFRange=First[InterpolatingFunctionDomain[Head[Soln[[1,2]]]]];
startT=Clip[tMin,{IFRange[[1]],IFRange[[2]]}];
stopT=Clip[tMax,{IFRange[[1]],IFRange[[2]]}];
fs=Map[#[[2]]&,Soln];
Which[
d==2,
PlotGraphicsPoints[ParametricPlot[Evaluate[fs],{t,startT,stopT},PlotPoints->SPs]],
d==3,
PlotGraphics3DPoints[ParametricPlot3D[Evaluate[fs],{t,startT,stopT},PlotPoints->SPs]],
True,
Table[fs,{t,startT,stopT,(stopT-startT)/SPs}]]]


(* ::Input::Initialization:: *)
Options[DisplayTrajectories]={TrajectoryPlotMode->From,Arrows->1,StateVariables->Automatic,PlotStyle->Automatic,PlotRange->StateSpace,Axes->Automatic,AxesLabel->Automatic,Frame->Automatic,FrameLabel->Automatic,BoxStyle->{Thickness[0.001],GrayLevel[0.7]},PlotPoints->100,PlotRangeClipping->True};


(* ::Input::Initialization:: *)
DisplayTrajectories[ds_DynamicalSystem,ListOfYIs_List,Duration_,opts___?OptionQ]:=Module[{Opts,G2Opts,G3Opts,trajs,trajs2,TrajOpts,SVs,BadSVs,SP,AX,PR,FR,ALabels,FLabels,AR,PS,TM,Arws,G2Options,G3Options,n=DSDimension[ds],is},
(* Process Options *)
Opts=Join[{opts},Options[DisplayTrajectories]];
If[n==1||n==2,Opts=Join[Opts,Options[Graphics]],Opts=Join[Opts,Options[Graphics3D]]];
TrajOpts=Sequence@@FilterRules[Opts,Options[Trajectory]];
G2Opts=FilterRules[Opts,Options[Graphics]];
G3Opts=FilterRules[Opts,Options[Graphics3D]];
SVs=StateVariables/.Opts;
If[SVs===Automatic,If[n<=3,SVs=DSStateVariables[ds],SVs=Take[DSStateVariables[ds],3]]];
BadSVs=Complement[SVs,DSStateVariables[ds]];If[BadSVs=!={},Print["Invalid state variables ",BadSVs," for ",ds]];
is=(MyPosition[#,DSStateVariables[ds]]&)/@SVs;
n=Length[SVs];
SP=PlotPoints/.Opts;
If[SP===Automatic,SP=100];
PR=PlotRange/.Opts;
(*If[PR===Automatic||PR===All,PR=StateSpace];*)
If[PR===StateSpace,PR=Thread[{DSYMins[ds],DSYMaxs[ds]}][[is]]];
If[n==1,If[ListQ[PR[[1]]],PR={PR[[1]],{0,0}},PR={PR,{0,0}}]];
AX=Axes/. Opts;
If[AX===Automatic,Which[n==1,AX={True,False},n==2,AX=False,n==3,AX=True]];
FR=Frame/. Opts;If[FR===Automatic,Which[n==1,FR=False,n==2,FR=True]];
ALabels=AxesLabel/. Opts;
If[ALabels===Automatic,ALabels=SVs];FLabels=FrameLabel/. Opts;If[FLabels===Automatic,FLabels=SVs];
AR=AspectRatio/. Opts;
If[AR===Automatic,Which[n==1,AR=1/8,n==2,AR=1,True,AR=Automatic]];
PS=PlotStyle/.Opts;
If[PS==Automatic,PS={Thickness[Switch[n,1,0.006,2,0.002,3,0.003]],Brown}];
If[!ListQ[PS],PS={PS}];
TM=TrajectoryPlotMode/.Opts;
Arws=Arrows/.Opts;
G2Opts=Join[{PlotRange->PR,Axes->AX,AxesLabel->ALabels,Frame->FR,FrameLabel->FLabels,AspectRatio->AR},G2Opts];
G3Opts=Join[{PlotRange->PR,Axes->AX,AxesLabel->ALabels},G3Opts];
(* Actually generate the trajectories *)
trajs=Map[TrajectorySegment[Trajectory[ds,#,Duration,TrajOpts],{0,Abs[Duration]},SamplePoints->SP]&,ListOfYIs];
If[TM===Through,
trajs2=Map[TrajectorySegment[Trajectory[ds,#,-Duration,TrajOpts],{0,Abs[Duration]},SamplePoints->SP]&,ListOfYIs];
trajs=MapThread[Join[Reverse[#1],#2]&,{trajs2,trajs}]];
$Trajectories=trajs;
trajs=Map[Select[#,InBounds[#,DSYMins[ds],DSYMaxs[ds]]&]&,trajs];
trajs=Map[Map[#[[is]]&,#]&,trajs];
If[n==1,trajs=Map[Map[{#[[1]],0}&,#]&,trajs]];
(* Display the trajectory plot *)
Which[
n==1,Show[Graphics[Join[PS,Line/@trajs,{Arrowheads[0.04]},Arrows[#,Arws]&/@trajs]],G2Opts],
n==2,Show[Graphics[Join[PS,Line/@trajs,{Arrowheads[0.03]},Arrows[#,Arws]&/@trajs]],G2Opts],
n==3,Show[Graphics3D[Join[PS,Line/@trajs,Arrows[#,Arws]&/@trajs]],G3Opts]]]


(* ::Input::Initialization:: *)
Arrows[pts_,numArrows_:1]:=
Module[{ds,\[CapitalDelta],arclen,next,arrows},
If[numArrows<1||Length[pts]<=1,Return[{}]];
ds=Map[ED[#[[1]],#[[2]]]&,Partition[pts,2,1]];
\[CapitalDelta]=(Plus@@ds)/(numArrows+1);
arrows=
If[ED[MapThread[Min,pts],MapThread[Max,pts]]<0.25,
{},
First[First[Rest[Reap[
For[i=1;arclen=0;next=\[CapitalDelta],i<=Length[ds],i++,
arclen+=ds[[i]];
If[arclen>next,Sow[{pts[[i]],pts[[i]]+Sqrt[(arclen-ds[[i]]-next)^2] (pts[[i+1]]-pts[[i]])/ED[pts[[i+1]],pts[[i]]]}];next+=\[CapitalDelta]]]]]]]];
If[Length[pts[[1]]]==2,Arrow/@arrows,Arrow3D/@arrows]]


(* ::Input::Initialization:: *)
Options[DisplayFlow]=
Join[{PlotPoints->Automatic,FlowPlotMode->Grid,InteriorPoints->{}},DeleteCases[Options[DisplayTrajectories],PlotPoints->_]];


(* ::Input::Initialization:: *)
DisplayFlow[ds_DynamicalSystem,Duration_,opts___?OptionQ]:=
Module[{n=DSDimension[ds],YMins=DSYMins[ds],YMaxs=DSYMaxs[ds],Opts,PPs,PM,IntPts,\[CapitalDelta],DTOpts,ListOfYIs,x1,x2,x3},
If[!(n<=3),Print["Dimension must be \[LessEqual] 3 for DisplayFlow"];Return[]];
Opts=Join[{opts},Options[DisplayFlow]];
DTOpts=FilterRules[Opts,Options[DisplayTrajectories]];
PPs=PlotPoints/.Opts;
PM=FlowPlotMode/.Opts;
IntPts=InteriorPoints/.Opts;
If[PPs===Automatic,Which[n==2,PPs=12,n==3,PPs=5]];
Switch[n,
1,
ListOfYIs={Mean[#]}&/@Partition[Union[Join[YMins,Map[First[LSPoint[#]]&,EquilibriumPoints[ds]],YMaxs]],2,1];
2,
Switch[PM,
Grid,
ListOfYIs=Join[IntPts,Flatten[Outer[List,Range[YMins[[1]],YMaxs[[1]],(YMaxs[[1]]-YMins[[1]])/PPs],Range[YMins[[2]],YMaxs[[2]],(YMaxs[[2]]-YMins[[2]])/PPs]],1]],
Boundary,
ListOfYIs=
Join[
IntPts,
Table[{x1,YMins[[2]]},{x1,YMins[[1]],YMaxs[[1]],(YMaxs[[1]]-YMins[[1]])/PPs}],
Table[{x1,YMaxs[[2]]},{x1,YMins[[1]],YMaxs[[1]],(YMaxs[[1]]-YMins[[1]])/PPs}],
Table[{YMins[[1]],x2},{x2,YMins[[2]],YMaxs[[2]],(YMaxs[[2]]-YMins[[2]])/PPs}],
Table[{YMaxs[[1]],x2},{x2,YMins[[2]],YMaxs[[2]],(YMaxs[[2]]-YMins[[2]])/PPs}]]];
3,
Switch[PM,
Grid,
ListOfYIs=Join[IntPts,Flatten[Outer[List,Range[YMins[[1]],YMaxs[[1]],(YMaxs[[1]]-YMins[[1]])/PPs],Range[YMins[[2]],YMaxs[[2]],(YMaxs[[2]]-YMins[[2]])/PPs],Range[YMins[[3]],YMaxs[[3]],(YMaxs[[3]]-YMins[[3]])/PPs]],2]],
Boundary,
ListOfYIs=
Join[
IntPts,
Map[Append[#,YMins[[3]]]&,Flatten[Outer[List,Range[YMins[[1]],YMaxs[[1]],(YMaxs[[1]]-YMins[[1]])/PPs],Range[YMins[[2]],YMaxs[[2]],(YMaxs[[2]]-YMins[[2]])/PPs]],1]],
Map[Append[#,YMaxs[[3]]]&,Flatten[Outer[List,Range[YMins[[1]],YMaxs[[1]],(YMaxs[[1]]-YMins[[1]])/PPs],Range[YMins[[2]],YMaxs[[2]],(YMaxs[[2]]-YMins[[2]])/PPs]],1]],
Map[{#[[1]],YMins[[2]],#[[2]]}&,Flatten[Outer[List,Range[YMins[[1]],YMaxs[[1]],(YMaxs[[1]]-YMins[[1]])/PPs],Range[YMins[[3]],YMaxs[[3]],(YMaxs[[3]]-YMins[[3]])/PPs]],1]],
Map[{#[[1]],YMaxs[[2]],#[[2]]}&,Flatten[Outer[List,Range[YMins[[1]],YMaxs[[1]],(YMaxs[[1]]-YMins[[1]])/PPs],Range[YMins[[3]],YMaxs[[3]],(YMaxs[[3]]-YMins[[3]])/PPs]],1]],
Map[Prepend[#,YMins[[3]]]&,Flatten[Outer[List,Range[YMins[[2]],YMaxs[[2]],(YMaxs[[2]]-YMins[[2]])/PPs],Range[YMins[[3]],YMaxs[[3]],(YMaxs[[3]]-YMins[[3]])/PPs]],1]],
Map[Prepend[#,YMaxs[[3]]]&,Flatten[Outer[List,Range[YMins[[2]],YMaxs[[2]],(YMaxs[[2]]-YMins[[2]])/PPs],Range[YMins[[3]],YMaxs[[3]],(YMaxs[[3]]-YMins[[3]])/PPs]],1]]]]];
ListOfYIs=N[ListOfYIs];
DisplayTrajectories[ds,ListOfYIs,Duration,TrajectoryPlotMode->Through,Sequence@@DTOpts]]


(* ::Input::Initialization:: *)
Options[EquilibriumPoints]=
{Tries->50,MaxIterations->100,
AccuracyGoal->Automatic};


(* ::Input::Initialization:: *)
EquilibriumPoints[ds_DynamicalSystem,opts___?OptionQ]:=Module[{fps,Opts={opts},PSubsts,Fs,Ys,YRanges,FROptions,J,EPs},PSubsts=DSParameterSubsts[ds];Fs=Thread[(DSFunctions[ds]/. PSubsts)==0];Ys=DSStateVariables[ds];YRanges=Thread[{DSYMins[ds],DSYMaxs[ds]}];J=DSJacobian[ds]/. PSubsts;fps=DSFreeParameters[ds];If[fps=!={},Print["Too many free parameters for EquilibriumPoints: ",fps];Return[{}]];CheckOptions[EquilibriumPoints,opts];tries=Tries/. Opts/. Options[EquilibriumPoints];FROptions={Sequence@@FilterRules[Flatten[{Sequence@@Join[{Jacobian->J},Opts]}],Options[FindRoot]]};EPs=Table[FindEP[Fs,Ys,YRanges,FROptions],{tries}];EPs=DeleteCases[EPs,$BADROOT]\[Union](SameTest->EqualPoint);EPs=Select[EPs,InBounds[#1,DSYMins[ds],DSYMaxs[ds]]&];EPs=(Module[{esys,evals,evecs,stability,type},esys=Sort[MapThread[{#1,#2}&,Eigensystem[J/. Thread[Ys->#1]]],Re[#1]<=Re[#2]&];evals=(#1[[1]]&)/@esys;evecs=(#1[[2]]&)/@esys;stability=EPStabilityFromEigenvalues[evals];type=EPTypeFromEigenvalues[evals];LimitSet[ds,EquilibriumPoint,#1,stability,type,evals,evecs]]&)/@EPs;Chop[EPs,$EqualityTolerance/100]]


(* ::Input::Initialization:: *)
FindEP[Fs_,Ys_,YRanges_,FROpts_]:=Module[{YIs,YSpecs,EP},YIs=(RandomReal[#1]&)/@YRanges;YSpecs=Thread[{Ys,YIs}];
EP=MyFindRoot[Fs,Sequence@@Join[YSpecs,FROpts]];
If[EP===$BADROOT,$BADROOT,Ys/. EP]]


(* ::Input::Initialization:: *)
EPStabilityFromEigenvalues[evs_]:=
Module[{ReEVs=Re[evs]},
Which[
SomeQ[(#\[TildeTilde]0)&,ReEVs],Nonhyperbolic,
EveryQ[Negative,ReEVs],Stable,
EveryQ[Positive,ReEVs],Unstable,
True,Saddle]]


(* ::Input::Initialization:: *)
EPTypeFromEigenvalues[evs_]:=
Module[{ImEVs=Im[evs]},
Which[
EveryQ[(#\[TildeTilde]0)&,ImEVs],Node,
EveryQ[!(#\[TildeTilde]0)&,ImEVs],Spiral,
True,Mixed]]


(* ::Input::Initialization:: *)
MergeEquilibriumPointLists[eps1_,eps2_]:=
Which[
eps1==={},eps2,
eps2==={},eps1,
True,Union[eps1,eps2,SameTest->(EqualPoint[LSPoint[#1],LSPoint[#2]]&)]]


(* ::Input::Initialization:: *)
Options[FindLimitCycle]=Sequence@@Join[Options[FindRoot],Options[NDSolve]];


(* ::Input::Initialization:: *)
FindLimitCycle[ds_DynamicalSystem,YIs_,T0_,Opts___]:=
Module[{fps,FROpts,NDOpts,R,T,Y0s=YIs,traj,FMs},
fps=DSFreeParameters[ds];
If[fps=!={},Print["Too many free parameters for FindLimitCycle: ",fps];Return[{}]];CheckOptions[FindLimitCycle,Opts];FROpts=Sequence@@FilterRules[Flatten[{Opts}],Options[FindRoot]];NDOpts=Sequence@@FilterRules[Flatten[{Opts}],Options[NDSolve]];
Y0s=Map[If[#\[TildeTilde]0,$EqualityTolerance,#]&,YIs];
With[{Ys=DSStateVariables[ds]},Module[{YSpecs,Gun,GunWrapper},YSpecs=Thread[{Append[Ys,T],(#1-$EqualityTolerance #1&)/@Append[Y0s,T0],(#1+$EqualityTolerance #1&)/@Append[Y0s,T0]}];Gun=MakeLCGun[ds,Y0s];Evaluate[GunWrapper[(Pattern[#1,_Real]&)/@Ys,T$_Real,NDOpts$_]]:=Gun@@{Ys,T$,NDOpts$};
Block[{$Messages,$MessageList={}},R=FindRoot[GunWrapper[Ys,T,{NDOpts}],Release[Sequence@@Join[YSpecs,{FROpts}]]];
If[Length[$MessageList]==0&&!(T/. R)\[TildeTilde]0,
traj=Trajectory[ds,Ys/. R,T/. R];
FMs=LimitCycleFloquetMultipliers[ds,Ys/.R,T/.R,traj];
LimitSet[ds,LimitCycle,Ys/. R,LimitCycleStability[FMs],T/. R,FMs,traj]]]]]]


(* ::Input::Initialization:: *)
MakeLCGun[ds_,Y0s_]:=
Block[{$Messages},
(* Extract DS info *)
With[{Ys=Unique[DSStateVariables[ds]]},
With[
{Fs=DSFunctions[ds]/.Thread[DSStateVariables[ds]->Ys]/.DSParameterSubsts[ds]},
(* Precompute F[Y0s] *)
With[{FY0s=N[Fs/.Thread[Ys->Y0s]],Yts=Map[(#[t])&,Ys]},
(* Precompute the dot product FY0s . (Next - Y0s) *)
With[{DP=Expand[FY0s . (Table[Next[[i]],{i,Length[Ys]}]-Y0s)]},(* Precompute the ODEs and compiled step function *)
With[
{Eqns=
Join[
Thread[Map[(#'[t])&,Ys]==(Fs/.Thread[Ys->Yts])],Thread[(Yts/.t->0)==Table[YIs$[[i]],{i,Length[Ys]}]]],
Foo=
Compile[{{YIs,_Real,1},{Next,_Real,1}},Append[YIs-Next,DP]]},
(* Build and return the gun function *)
Function[{YIs, T,NDOpts},
With[{S=NDSolve[Eqns,Yts,{t,0,T},MaxSteps->25000,Sequence@@NDOpts]},
Foo[YIs,Map[#[[2]]&,First[S]]/.t->T]]]]]]]]]


(* ::Input::Initialization:: *)
LimitCycleFloquetMultipliers[ds_,pt_,T_,traj_]:=
Module[{n=DSDimension[ds],Ys=DSStateVariables[ds],J,tt,m,ms,mts,mdts,minits,mRHSs,soln,M},
(* Construct the variational equation and solve it *)
J=DSJacobian[ds]/.DSParameterSubsts[ds]/.Thread[Ys->(#[tt]&/@Ys)]/.(traj/.t->tt);
ms=Flatten[Table[ToExpression["m"<>ToString[i]<>ToString[j]],{j,1,n},{i,1,n}],1];
mts=#[tt]&/@ms;
mdts=#'[tt]&/@ms;
minits=Thread[(mts/.tt->0)==Flatten[IdentityMatrix[n],1]];
m=Partition[mts,n];
mRHSs=Flatten[J . m,1];
soln=NDSolve[Join[Thread[mdts==mRHSs],minits],mts,{tt,0,T}];
(* Compute the monodromy matrix *)
M=m/.soln[[1]]/.tt->T;
(* Determine the limit cycle stability from its eigenvalues *)
Abs[Eigenvalues[M]]]


(* ::Input::Initialization:: *)
LimitCycleStability[FMs_]:=
Module[{n=Length[FMs],mevs,num1s,numl1s,numg1s},
mevs=Delete[FMs,MyPosition[Min[Abs[1-FMs]],Abs[1-FMs]]];
num1s=1+Length[Select[mevs,(#\[TildeTilde]1)&]];
numl1s=Length[Select[mevs,((!(#\[TildeTilde]1))&&(#<1))&]];
numg1s=Length[Select[mevs,((!(#\[TildeTilde]1))&&(#>1))&]];
Which[
num1s>1,Nonhyperbolic,
numl1s==n-1,Stable,
numg1s==n-1,Unstable,
True,Saddle]]


(* ::Input::Initialization:: *)
Options[DisplayPhasePortrait]={EquilibriumPointStyle->{PointSize[0.025`]},SaddleManifolds->False,SaddleManifoldInitialStep:>10 $EqualityTolerance,SaddleManifoldDuration->75,SaddleManifoldPlotPoints->50,SaddleManifoldArrows->1,SaddleManifoldStyle->{Thickness[0.003`]},NullManifolds->False,NullManifold2Style->{Thickness[0.0025`],GrayLevel[0.6`]},NullManifold2PlotPoints->50,NullManifold3PlotPoints->Automatic,NullManifoldOpacity->1,LimitSets->{},StateVariables->Automatic,Tries->50,MaxIterations->100,AccuracyGoal->Automatic,AspectRatio->Automatic,Axes->Automatic,AxesLabel->Automatic,AxesStyle->Automatic,Epilog->{},Frame->Automatic,FrameLabel->Automatic,FrameStyle->Automatic,FrameTicks->Automatic,GridLines->None,PlotLabel->None,RotateLabel->True,PlotRange->StateSpace,Prolog->{},Ticks->Automatic,DisplayFunction:>$DisplayFunction,Boxed->True,BoxRatios->{1,1,1},BoxStyle->{Thickness[0.001`],GrayLevel[0.7`]},Lighting->Automatic,ViewPoint->{1.2`,-2.4`,2.`},PlotRangeClipping->True};


(* ::Input::Initialization:: *)
$DefaultEPStabilityStyles =
{Stable->Blue,Saddle->Green,Unstable->Red,Nonhyperbolic->Black};

$DefaultSaddleManifoldStabilityStyles=
{Stable->Blue,Unstable->Red};


(* ::Input::Initialization:: *)
DisplayPhasePortrait[ds_DynamicalSystem,opts___?OptionQ]:=Module[{fps,Opts,EPOpts,G2Opts,G3Opts,SVs,BadSVs,is,PR,TOpts,DoSMs,DoNMs,NM2Style,SMIStep,SMDur,EPStyle,SMStyle,SMPPs,SMArws,NM2PPs,NM3PPs,NM3EPs,NMO,AX,FR,ALabels,FLabels,AR,EPs,LSs,LCs,n,g,SEPs={},SMGs={},NMs={}},n=DSDimension[ds];
fps=DSFreeParameters[ds];If[fps=!={},Print["Too many free parameters for DisplayPhasePortrait: ",fps];Return[{}]];CheckOptions[DisplayPhasePortrait,opts];Opts=Sequence@@Join[{opts},Options[DisplayPhasePortrait]];EPOpts=Sequence@@FilterRules[Flatten[{Opts}],Options[EquilibriumPoints]];G2Opts=Sequence@@FilterRules[Flatten[{Opts}],Options[Graphics]];G3Opts=Sequence@@FilterRules[Flatten[{Opts}],Options[Graphics3D]];
SVs=StateVariables/.{Opts};
If[SVs===Automatic,
If[n<=3,SVs=DSStateVariables[ds],SVs=Take[DSStateVariables[ds],3]]];
BadSVs=Complement[SVs,DSStateVariables[ds]];If[BadSVs=!={},Print["Invalid state variables ",BadSVs," for ",ds]];
is=(MyPosition[#,DSStateVariables[ds]]&)/@SVs;
n=Length[SVs];
PR=PlotRange/. {Opts};
If[PR===StateSpace,PR=Thread[{DSYMins[ds],DSYMaxs[ds]}][[is]]];
If[n==1,If[ListQ[PR[[1]]],PR={PR[[1]],{0,0}},PR={PR,{0,0}}]];TOpts=Sequence@@FilterRules[Flatten[{Opts}],Options[Trajectory]];Opts={Opts};DoSMs=SaddleManifolds/. Opts;DoNMs=NullManifolds/. Opts;NM2Style=NullManifold2Style/. Opts;If[Head[NM2Style]=!=List,NM2Style={NM2Style}];SMIStep=SaddleManifoldInitialStep/. Opts;SMDur=SaddleManifoldDuration/. Opts;EPStyle=EquilibriumPointStyle/. Opts;If[Head[EPStyle]=!=List,EPStyle={EPStyle}];SMStyle=SaddleManifoldStyle/. Opts;If[Head[SMStyle]=!=List,SMStyle={SMStyle}];SMPPs=SaddleManifoldPlotPoints/. Opts;
SMArws=SaddleManifoldArrows/.Opts;
NM2PPs=NullManifold2PlotPoints/. Opts;
NM3PPs=NullManifold3PlotPoints/. Opts;AX=Axes/. Opts;
NMO=NullManifoldOpacity/.Opts;
If[AX===Automatic,Which[n==1,AX={True,False},n==2,AX=False,n==3,AX=True]];FR=Frame/. Opts;If[FR===Automatic,Which[n==1,FR=False,n==2,FR=True]];ALabels=AxesLabel/. Opts;If[ALabels===Automatic,ALabels=SVs];FLabels=FrameLabel/. Opts;If[FLabels===Automatic,FLabels=SVs];AR=AspectRatio/. Opts;If[AR===Automatic,Which[n==1,AR=1/8,n==2,AR=1,True,AR=Automatic]];G2Opts=Join[{PlotRange->PR,Axes->AX,AxesLabel->ALabels,Frame->FR,FrameLabel->FLabels,AspectRatio->AR},{G2Opts}];G3Opts=Join[{PlotRange->PR,Axes->AX,AxesLabel->ALabels},{G3Opts}];LSs=LimitSets/. Opts;
EPs=EquilibriumPoints[ds,EPOpts];
EPs=MergeEquilibriumPointLists[EPs,Select[LSs,LSType[#1]===EquilibriumPoint&]];
LCs=Select[LSs,LSType[#1]===LimitCycle&];
$PhasePortraitEPs=EPs;
LSs=Select[LSs,!LSType[#1]===EquilibriumPoint&];
If[n==1,g=Join[EPStyle,({EPColorFromStability[LSStability[#1]],Point[{First[LSPoint[#1]],0}]}&)/@EPs],g=Join[EPStyle,({EPColorFromStability[LSStability[#1]],Point[LSPoint[#1][[is]]]}&)/@EPs]];
If[DoSMs==True,
SEPs=Select[EPs,LSStability[#1]===Saddle&];
SMGs=(MakeSaddleTrajGraphics[ds,#1,is,SMPPs,{TOpts},SMIStep,SMDur,SMStyle,SMArws]&)/@SEPs];
If[DoNMs==True||(ListQ[DoNMs]&&Length[DoNMs]==3),
If[DSDimension[ds]<=3,
If[DoNMs==True,DoNMs={True,True,True}];
Which[
n==2,NMs=MakeNullManifoldGraphics2[ds,NM2PPs,NM2Style],
n==3,NMs=MakeNullManifoldGraphics3[ds,NM3PPs,NMO,DoNMs]]]];
g=Join[g,MakeLCGraphics[#,is]&/@LCs];
Which[n==1,Show[Graphics[{EPStyle,g}],G2Opts],n==2,Show[Graphics[{NMs,SMGs,EPStyle,g}],G2Opts],n==3,Show@@{Graphics3D[{SMGs,EPStyle,g}],NMs,G3Opts}]]


(* ::Input::Initialization:: *)
MakeLCGraphics[LC_,is_]:=
Module[{T=LCPeriod[LC],traj},
traj=TrajectorySegment[Trajectory[LSDynamicalSystem[LC],LSPoint[LC],T],T];
{EPColorFromStability[LSStability[LC]],Line[#[[is]]&/@traj],Arrows[#[[is]]&/@traj,1]}]



(* ::Input::Initialization:: *)
MakeNullManifoldGraphics2[ds_DynamicalSystem,PPs_,NMStyle_]:=
Block[{$DisplayFunction=Identity},
Module[{DSFns,YRanges,g1,g2},
DSFns=DSFunctions[ds]/.DSParameterSubsts[ds];
YRanges=Thread[{DSStateVariables[ds],DSYMins[ds],DSYMaxs[ds]}];
g1=First[Normal[ContourPlot[Evaluate[DSFns[[1]]==0],Evaluate[YRanges[[1]]],Evaluate[YRanges[[2]]],PlotPoints->PPs]]];
g2=First[Normal[ContourPlot[Evaluate[DSFns[[2]]==0],Evaluate[YRanges[[1]]],Evaluate[YRanges[[2]]],PlotPoints->PPs]]];
g1=Map[If[Head[#]==Tooltip,#[[1]],#]&,Flatten[Normal[g1]]];
g2= Map[If[Head[#]==Tooltip,#[[1]],#]&,Flatten[Normal[g2]]];
Join[NMStyle,{Cases[g1,Line[_],\[Infinity]],Cases[g2,Line[_],\[Infinity]]}]]]


(* ::Input::Initialization:: *)
MakeNullManifoldGraphics3[ds_DynamicalSystem,PPs_,NMO_,DoNMs_]:=Block[{$DisplayFunction=Identity},Module[{DSFns,YRanges,g1=Graphics3D[{}],g2=Graphics3D[{}],g3=Graphics3D[{}]},DSFns=DSFunctions[ds]/. DSParameterSubsts[ds];YRanges=Thread[{DSStateVariables[ds],DSYMins[ds],DSYMaxs[ds]}];
If[DoNMs[[1]],
g1=ContourPlot3D@@{DSFns[[1]]==0,YRanges[[1]],YRanges[[2]],YRanges[[3]],PlotPoints->PPs,ContourStyle->{{Opacity[NMO],RGBColor[1,0.75`,1]}}}];
If[DoNMs[[2]],g2=ContourPlot3D@@{DSFns[[2]]==0,YRanges[[1]],YRanges[[2]],YRanges[[3]],PlotPoints->PPs,ContourStyle->{{Opacity[NMO],RGBColor[0.75`,1,0.75`]}}}];If[DoNMs[[3]],g3=ContourPlot3D@@{DSFns[[3]]==0,YRanges[[1]],YRanges[[2]],YRanges[[3]],PlotPoints->PPs,ContourStyle->{{Opacity[NMO],RGBColor[0.75`,1,1]}}}];
{g1,g2,g3}]]


(* ::Input::Initialization:: *)
EPColorFromStability[st_]:=st/.$DefaultEPStabilityStyles


(* ::Input::Initialization:: *)
MakeSaddleTrajGraphics[ds_DynamicalSystem,ep_LimitSet,is_,SPs_,TOptL_,\[CapitalDelta]_,MaxDur_,SMStyle_,SMArws_]:=
Block[{t},
Module[{pt,evals,evecs,gs1={},gs2={},gu1={},gu2={}},
pt=LSPoint[ep];
evals=EPEigenvalues[ep];
evecs=EPEigenvectors[ep];
(* Construct the stable manifold if it is 1-dimensional *)
npick=Negative/@evals;
nevals=Pick[evals,npick];
If[Length[nevals]==1,
Module[{neval=First[nevals],nevec=First[Pick[evecs,npick]],s,L},
(* Trace the first part of the stable saddle manifold *)
s=Trajectory[ds,pt+\[CapitalDelta] nevec,-MaxDur,Sequence@@TOptL,MaxSteps->25000];
L=#[[is]]&/@TrajectorySegment[s,MaxDur,SamplePoints->SPs];
gs1=Join[SMStyle,{Stable/.$DefaultSaddleManifoldStabilityStyles,Line[L],Arrows[Reverse[L],SMArws]}];
(* Trace the second part of the stable saddle manifold *)
s=Trajectory[ds,pt-\[CapitalDelta] nevec,-MaxDur,Sequence@@TOptL,MaxSteps->25000];
L=#[[is]]&/@TrajectorySegment[s,MaxDur,SamplePoints->SPs];
gs2=Join[SMStyle,{Stable/.$DefaultSaddleManifoldStabilityStyles,Line[L],Arrows[Reverse[L],SMArws]}]]];
(* Construct the unstable manifold if it is 1-dimensional *)
ppick=Positive/@evals;
pevals=Pick[evals,ppick];
If[Length[pevals]==1,
Module[{peval=First[pevals],pevec=First[Pick[evecs,ppick]],s,L},
(* Trace the first part of the unstable saddle manifold *)
s=Trajectory[ds,pt+\[CapitalDelta] pevec,MaxDur,Sequence@@TOptL,MaxSteps->25000];
L=#[[is]]&/@TrajectorySegment[s,MaxDur,SamplePoints->SPs];
gu1=Join[SMStyle,{Unstable/.$DefaultSaddleManifoldStabilityStyles,Line[L],Arrows[L,SMArws]}];
(* Trace the second part of the unstable saddle manifold *)
s=Trajectory[ds,pt-\[CapitalDelta] pevec,MaxDur,Sequence@@TOptL,MaxSteps->25000];
L=#[[is]]&/@TrajectorySegment[s,MaxDur,SamplePoints->SPs];
gu2=Join[SMStyle,{Unstable/.$DefaultSaddleManifoldStabilityStyles,Line[L],Arrows[L,SMArws]}]]];
{gs1,gs2,gu1,gu2}]]


(* ::Input::Initialization:: *)
ContinueSolution[fs_,Ys_,YMins_,YMaxs_,YIs_,InitTan_,Init\[CapitalDelta]s_,Min\[CapitalDelta]s_,Max\[CapitalDelta]s_,MaxSteps_,TestFns_,VerifyFns_,FROpts_]:=
Module[{NewYSyms,Fs,Eqns,J,\[CapitalDelta]ss,\[CapitalDelta]s,t,Branch,OldYVals,YVals,PredYVals,OldTestVals,NewTestVals,Subs,root,StepCount},
(* Initialization *)
NewYSyms=Unique[Ys,Temporary];
Fs=Append[fs,Apply[Plus,(Ys-NewYSyms)^2]-\[CapitalDelta]ss^2];Eqns=Thread[Fs==0];
J=JacobianMatrix[Fs,Ys];
StepCount=0;
\[CapitalDelta]s=Init\[CapitalDelta]s;t=Init\[CapitalDelta]s*InitTan/Norm[InitTan];YVals=YIs;OldYVals =YIs-t;
PredYVals=YIs+t;
Branch=LinkedList[YVals];
OldTests=NewTests=Map[MyChop[Apply[#,YIs]]&,TestFns];
(* Trace the branch until it passes out of range *)
While[InBounds[YVals,YMins,YMaxs],
(* If we've been following too long, we may have a loop, so terminate *)
If[StepCount++>MaxSteps,
Print["Warning: MaxSteps exceeded, terminating branch"];Return[{LinkedListToList[Branch],$MaxStepCountExceeded,{}}]];
(* Solve for the next point *)
Subs=Join[{\[CapitalDelta]ss-> \[CapitalDelta]s},Thread[NewYSyms->YVals]];
root = 
Apply[MyFindRoot,Join[{Eqns/.Subs},Thread[{Ys,PredYVals}],{Jacobian->J/.Subs},FROpts]];
(* If we didn't converge, reduce the step size and try again if we can, otherwise punt *)
If[root===$BADROOT,
If[\[CapitalDelta]s/2>Min\[CapitalDelta]s,
(\[CapitalDelta]s=\[CapitalDelta]s/2;PredYVals=YVals+(\[CapitalDelta]s/Norm[YVals-OldYVals])(YVals-OldYVals);Continue[]),
Return[{LinkedListToList[Branch],$ConvergenceFailure,{}}]]];
(* Set up next step *)
\[CapitalDelta]s=Min[2 \[CapitalDelta]s,Max\[CapitalDelta]s];OldYVals=YVals;YVals=Ys/.root;
PredYVals=YVals+(\[CapitalDelta]s/Norm[Chop[YVals-OldYVals]])Chop[YVals-OldYVals];
OldTests=NewTests;NewTests=Map[MyChop[Apply[#,YVals]]&,TestFns];
(* If we passed a verified special point, solve for it and terminate the branch *)
If[SomeQ[Negative,t=OldTests*NewTests],
Module[{i},
i=MyPosition[-1,Sign[t]];
Fs=Append[fs,CompiledFunctionSource[TestFns[[i]]]];
root=Apply[MyFindRoot,Join[{Thread[Fs==0]},Thread[{Ys,YVals}],{FROpts}]];
While[root===$BADROOT && \[CapitalDelta]s/2>Min\[CapitalDelta]s,
\[CapitalDelta]s=\[CapitalDelta]s/2;YVals=OldYVals+(\[CapitalDelta]s/Norm[YVals-OldYVals])(YVals-OldYVals);
root=Apply[MyFindRoot,Join[{Thread[Fs==0]},Thread[{Ys,YVals}],{FROpts}]]];
If[root===$BADROOT,Return[{LinkedListToList[Branch],$ConvergenceFailure,{}}]];
If[Apply[VerifyFns[[i]],Ys/.root],
Return[{LinkedListToList[LinkedList[Branch,Ys/.root]],$SpecialPoint,Ys/.root}],
\[CapitalDelta]s=Max\[CapitalDelta]s]]];
(* Record the current point *)
If[StepCount>1,
Branch=LinkedList[Branch,OldYVals]]];
(* Determine which Y passed out of bounds and solve for and record the exact boundary *)
Module[{LTs,GTs, i,YVal,TYs,TNewYs},
LTs=Flatten[Position[Thread[YVals>=YMins],False]];
GTs=Flatten[Position[Thread[YVals<=YMaxs],False]];
If[LTs==={},(i=GTs[[1]];YVal=YMaxs[[i]]),(i=LTs[[1]];YVal=YMins[[i]])];
TYs=Delete[Ys,i];TNewYs=Delete[YVals,i];
root=Apply[MyFindRoot,Join[{Thread[(fs/.Ys[[i]]->YVal)==0]},Thread[{TYs,TNewYs}],FROpts]];
If[root===$BADROOT,Return[{LinkedListToList[Branch],$ConvergenceFailure,{}}]];
Branch = LinkedList[Branch,Ys/.root/.Ys[[i]]->YVal];
{LinkedListToList[Branch],$BoundsViolation,{}}]]


(* ::Input::Initialization:: *)
Options[FollowSolutionBranch]=
{SolveForInitialPointFixing->False,
StartingStepSize->Automatic,MinStepSize->Automatic,MaxStepSize->Automatic,MaxSteps->1000,
SwitchBranches->True,TestExpressions->{},VerificationExpressions->{},
MaxBend->10,
MaxIterations->100,AccuracyGoal->Automatic,WorkingPrecision->$MachinePrecision};


(* ::Input::Initialization:: *)
FollowSolutionBranch[fs_List,YSpecs_List,opts___?OptionQ]:=Module[{Ys,YIs,YMins,YMaxs,Opts,FSBOpts,InitSolveVar,Init\[CapitalDelta]s,Min\[CapitalDelta]s,Max\[CapitalDelta]s,TestExprs,VerifyExprs,MaxStps,SwitchBrnchs,MaxBnd,FROpts,J,InitTan,TestFns,VerifyFns,NSpace,t,BR1,BR2,BRs,TC1,TC2,SP1,SP2,SPs,L},If[Length[fs]!=Length[YSpecs]-1,Print["The number of expressions must be one less than the number of parameters"];Return[{{},{}}]];Ys=(#1[[1]]&)/@YSpecs;YIs=(#1[[2]]&)/@YSpecs;YMins=(#1[[3]]&)/@YSpecs;YMaxs=(#1[[4]]&)/@YSpecs;CheckOptions[FollowSolutionBranch,opts];Opts={opts};FSBOpts=Options[FollowSolutionBranch];InitSolveVar=SolveForInitialPointFixing/. Opts/. FSBOpts;Min\[CapitalDelta]s=MinStepSize/. Opts/. FSBOpts;If[Min\[CapitalDelta]s===Automatic,Min\[CapitalDelta]s=10.` $EqualityTolerance];Max\[CapitalDelta]s=MaxStepSize/. Opts/. FSBOpts;If[Max\[CapitalDelta]s===Automatic,Max\[CapitalDelta]s=Min[YMaxs-YMins]/35.`];If[Max\[CapitalDelta]s<Min\[CapitalDelta]s,{Min\[CapitalDelta]s,Max\[CapitalDelta]s}={Max\[CapitalDelta]s,Min\[CapitalDelta]s}];Init\[CapitalDelta]s=StartingStepSize/. Opts/. FSBOpts;If[Init\[CapitalDelta]s===Automatic,Init\[CapitalDelta]s=10^(1/2 (Log[10,Min\[CapitalDelta]s]+Log[10,Max\[CapitalDelta]s]))];TestExprs=TestExpressions/. Opts/. FSBOpts;
VerifyExprs=PadRight[VerificationExpressions/. Opts/. FSBOpts,Length[TestExprs],True];MaxStps=MaxSteps/. Opts/. FSBOpts;MaxBnd=MaxBend/. Opts/. FSBOpts;SwitchBrnchs=SwitchBranches/. Opts/. FSBOpts;FROpts=Sequence@@FilterRules[Flatten[{Sequence@@Join[Opts,FSBOpts]}],Options[FindRoot]];J=JacobianMatrix[fs,Ys];TestFns=(Compile@@{Ys,#1}&)/@TestExprs;VerifyFns=(Function@@{Ys,#1}&)/@VerifyExprs;If[InitSolveVar=!=False,If[MemberQ[Ys,InitSolveVar],Module[{i,ys,yis,root},i=MyPosition[InitSolveVar,Ys];ys=Delete[Ys,i];yis=Delete[YIs,i];root=FindRoot@@Join[Thread[(fs/. Ys[[i]]->YIs[[i]])==0],Thread[{ys,yis}],{FROpts}];
If[root===$BADROOT,Print["Unable to solve for initial point"];Return[{{},{}}],YIs=Ys/. Ys[[i]]->YIs[[i]]/. root]],{Print["Invalid value for SolveForInitialPointFixing: ",InitSolveVar];Return[{{},{}}]}]];NSpace=MyNullSpace[J/. Thread[Ys->YIs]];
If[Length[NSpace]!=1,
Print["Only codimension 1 solutions can be followed"];Print["Found a codimension ",Length[NSpace], " solution at ",Ys,"=",YIs];
Return[{{},{}}]];
InitTan=First[NSpace];SPs={};{BR1,TC1,SP1}=ContinueSolution[fs,Ys,YMins,YMaxs,YIs,InitTan,Init\[CapitalDelta]s,Min\[CapitalDelta]s,Max\[CapitalDelta]s,MaxStps,TestFns,VerifyFns,{FROpts}];
If[TC1===$SpecialPoint,SPs=AppendTo[SPs,SP1]];
{BR2,TC2,SP2}=ContinueSolution[fs,Ys,YMins,YMaxs,YIs,-InitTan,Init\[CapitalDelta]s,Min\[CapitalDelta]s,Max\[CapitalDelta]s,MaxStps,TestFns,VerifyFns,{FROpts}];
If[TC2===$SpecialPoint&&!EqualPoint[SP1,SP2],AppendTo[SPs,SP2]];If[TC1===$ConvergenceFailure||TC2===$ConvergenceFailure,Print["Warning: A convergence failure occurred during continuation"]];Which[BR1==={}&&BR2==={},BRs={},BR1==={},BRs={BR2},BR2==={},BRs={BR1},True,BRs={Join[Reverse[BR1],Drop[BR2,1],{}]}];If[SwitchBrnchs,L={};If[TC1===$SpecialPoint,NSpace=MyNullSpace[J/. Thread[Ys->SP1]];(AppendTo[L,{SP1,#1}]&)/@FilterNullSpace[NSpace,BR1]];If[TC2===$SpecialPoint&&!EqualPoint[SP1,SP2],NSpace=MyNullSpace[J/. Thread[Ys->SP2]];(AppendTo[L,{SP2,#1}]&)/@FilterNullSpace[NSpace,BR2]];While[Length[L]>0,{SP1,InitTan}=First[L];L=Rest[L];{BR2,TC2,SP2}=ContinueSolution[fs,Ys,YMins,YMaxs,SP1,InitTan,Init\[CapitalDelta]s,Min\[CapitalDelta]s,Max\[CapitalDelta]s,MaxStps,TestFns,VerifyFns,{FROpts}];If[TC2===$ConvergenceFailure,Print["Warning: A convergence failure occurred during continuation"];Continue[]];If[BR2=!={},AppendTo[BRs,BR2]];If[SP2=!={}&&!SomeQ[EqualPoint[SP2,#1]&,SPs],AppendTo[SPs,SP2];NSpace=MyNullSpace[J/. Thread[Ys->SP2]];(AppendTo[L,{SP2,#1}]&)/@FilterNullSpace[NSpace,BR2]];]];{BRs,SPs}]


(* ::Input::Initialization:: *)
FilterNullSpace[NSpace_,BR_]:=
Module[{NS,t,v,p},
NS=Join[NSpace,-NSpace];
t=Subtract@@Take[BR,-2];
v=MyChop[VectorAngle[#,t]&/@NS];
p=Position[v,Min[v]];
Delete[NS,First[p]]]


(* ::Input::Initialization:: *)
Options[FollowEquilibriumBranch]:=
{NeutralSaddles->False,
StartingStepSize->Automatic,MinStepSize->Automatic,MaxStepSize->Automatic,MaxSteps->250,SwitchBranches->True,MaxBend->10,
MaxIterations->100,AccuracyGoal->Automatic,WorkingPrecision->$MachinePrecision}


(* ::Input::Initialization:: *)
FollowEquilibriumBranch[ep_LimitSet,\[Lambda]_?SymbolQ,opts___?OptionQ]:=Module[{ds,fps,PSubs,Opts,FSBOpts,NSaddles,Fs,ys,Ys,YIs,\[Lambda]start,i\[Lambda],YMins,YMaxs,J,\[Phi]1,\[Phi]2,TestExprs,VExprs,BRs,SPs},
ds=LSDynamicalSystem[ep];
\[Lambda]start=\[Lambda]/. DSParameterSubsts[ds];
ds=DSClearParameters[ds,{\[Lambda]}];
fps=DSFreeParameters[ds];
If[Length[fps]>1,Print["Too many free parameters for FollowEquilibriumBranch: ",fps];Return[{{},{}}]];CheckOptions[FollowEquilibriumBranch,opts];Opts={opts};FSBOpts=Sequence@@FilterRules[Flatten[{Sequence@@Join[Opts,Options[FollowEquilibriumBranch]]}],Options[FollowSolutionBranch]];NSaddles=NeutralSaddles/. Opts/. Options[FollowEquilibriumBranch];
PSubs=DSParameterSubsts[ds];
Ys=Append[DSStateVariables[ds],\[Lambda]];
YIs=Append[LSPoint[ep],\[Lambda]start];
i\[Lambda]=MyPosition[\[Lambda],DSParameters[ds]];
YMins=Append[DSYMins[ds],DS\[Lambda]Mins[ds][[i\[Lambda]]]];
YMaxs=Append[DSYMaxs[ds],DS\[Lambda]Maxs[ds][[i\[Lambda]]]];
Fs=DSFunctions[ds]/. PSubs;
J=DSJacobian[ds]/. PSubs;
If[DS\[Phi]1[ds]===Numerical,
\[Phi]1=NDet[J];\[Phi]2=NDet[2 J\[CircleDot]IdentityMatrix[Length[DSStateVariables[ds]]]],
\[Phi]1=DS\[Phi]1[ds]/. PSubs;\[Phi]2=DS\[Phi]2[ds]/. PSubs];
If[DSDimension[ds]>1,TestExprs={\[Phi]1,\[Phi]2};If[NSaddles,VExprs={},VExprs={True,SomeQ[PureImaginaryQ,NEigenvalues[J]]}],TestExprs={\[Phi]1};VExprs={}];
{BRs,SPs}=FollowSolutionBranch[Fs,Thread[{Ys,MyChop[YIs],YMins,YMaxs}],TestExpressions->TestExprs,VerificationExpressions->VExprs,FSBOpts];
BRs=(MakeEPBranchObject[ds,\[Lambda],#1]&)/@BRs;
SPs=(MakeBifurcationObject[ds,\[Lambda],#1,\[Phi]1,\[Phi]2]&)/@SPs;{BRs,SPs}]/;LSType[ep]===EquilibriumPoint


(* ::Input::Initialization:: *)
MakeEPBranchObject[ds_,\[Lambda]_,B_]:=
Module[{J,EVs},
J=DSJacobian[ds];
J=J/.Thread[Join[DSStateVariables[ds],{\[Lambda]}]->B[[Round[Length[B]/2]]]]/.DSParameterSubsts[ds];
EVs=Eigenvalues[J];
EquilibriumBranch[
ds,
Which[
EveryQ[Negative,Re[EVs]],Stable,
EveryQ[Positive,Re[EVs]],Unstable,
True,Saddle],
\[Lambda],
B]]


(* ::Input::Initialization:: *)
MakeBifurcationObject[ds_,\[Lambda]_,P_,\[Phi]1_,\[Phi]2_]:=
Module[{Ys=Append[DSStateVariables[ds],\[Lambda]],J=DSJacobian[ds],D\[Lambda]},
J=J/.Thread[Ys->P]/.DSParameterSubsts[ds];
D\[Lambda]=Transpose[{\!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Lambda]\)]\ \(DSFunctions[ds]\)\)}]/.Thread[Ys->P]/.DSParameterSubsts[ds];
Chop[
BifurcationPoint[
ds/.{\[Lambda]-> Last[P]},
Which[
(* Determinant of Jacobian is zero *)
(\[Phi]1/.Thread[Ys->P])\[TildeTilde]0,
If[Length[MyNullSpace[AppendRows[J,D\[Lambda]]]]>1,Branch,Fold],
(* Determinant of bialternate product is zero *)
(DSDimension[ds]>1)&&((\[Phi]2/.Thread[Ys->P])\[TildeTilde]0),
If[SomeQ[PureImaginaryQ,NEigenvalues[J]],Hopf,NeutralSaddle],
(* Default *)
True,Unknown],
Drop[P,-1]],
$EqualityTolerance/100]]


(* ::Input::Initialization:: *)
Options[EquilibriumBranches]=
{InteriorPoints->{},InteriorGrid->0,
NeutralSaddles->False,
StartingStepSize->Automatic,MinStepSize->Automatic,MaxStepSize->Automatic,MaxSteps->250,SwitchBranches->True,MaxBend->10,
Tries->50,
MaxIterations->100,AccuracyGoal->Automatic,WorkingPrecision->$MachinePrecision};


(* ::Input::Initialization:: *)
EquilibriumBranches[dds_DynamicalSystem,\[Lambda]_?SymbolQ,opts___]:=Module[{ds,fps,Opts,EPOptions,FEBOptions,IntPnts,IntGrd,i\[Lambda],\[Lambda]Min,\[Lambda]Max,EPs,EB1s,EB2s,EBs,i},ds=DSClearParameters[dds,{\[Lambda]}];fps=DSFreeParameters[ds];If[Length[fps]>1,Print["Too many free parameters for EquilibriumBranches: ",fps];Return[{{},{}}]];CheckOptions[EquilibriumBranches,opts];Opts={opts};EPOptions=Sequence@@FilterRules[Flatten[{Sequence@@Join[Opts,Options[EquilibriumBranches]]}],Options[EquilibriumPoints]];FEBOptions=Sequence@@FilterRules[Flatten[{Sequence@@Join[Opts,Options[EquilibriumBranches]]}],Options[FollowEquilibriumBranch]];IntPnts=InteriorPoints/. Opts/. Options[EquilibriumBranches];IntGrd=InteriorGrid/. Opts/. Options[EquilibriumBranches];i\[Lambda]=MyPosition[\[Lambda],DSParameters[ds]];\[Lambda]Min=DS\[Lambda]Mins[ds][[i\[Lambda]]];\[Lambda]Max=DS\[Lambda]Maxs[ds][[i\[Lambda]]];With[{gstep=(\[Lambda]Max-\[Lambda]Min)/(IntGrd+1)},IntPnts=Join[IntPnts,Range[\[Lambda]Min+gstep,\[Lambda]Max-gstep,gstep]]];EBs={{},{}};EPs=EquilibriumPoints[ds/. \[Lambda]->\[Lambda]Min,EPOptions];For[i=1,i<=Length[EPs],i++,If[NewEquilibriumBranch[EPs[[i]],EBs[[1]],\[Lambda]Min],EBs=MergeBifurcationData[EBs,FollowEquilibriumBranch[EPs[[i]],\[Lambda],FEBOptions]]]];EPs=EquilibriumPoints[ds/. \[Lambda]->\[Lambda]Max,EPOptions];For[i=1,i<=Length[EPs],i++,If[NewEquilibriumBranch[EPs[[i]],EBs[[1]],\[Lambda]Max],EBs=MergeBifurcationData[EBs,FollowEquilibriumBranch[EPs[[i]],\[Lambda],FEBOptions]]]];For[i=1,i<=Length[IntPnts],i++,EPs=EquilibriumPoints[ds/. \[Lambda]->IntPnts[[i]],EPOptions];EB1s=(FollowEquilibriumBranch[#1,\[Lambda],FEBOptions]&)/@EPs;EBs=Fold[MergeBifurcationData,EBs,EB1s]];EBs]


(* ::Input::Initialization:: *)
NewEquilibriumBranch[EP_,EBs_,\[Lambda]_]:=
Module[{EPpt=Join[LSPoint[EP],{\[Lambda]}]},
!SomeQ[(EqualPoint[EPpt,First[EBPoints[#]]]\[Or]EqualPoint[EPpt,Last[EBPoints[#]]])&,
EBs]]


(* ::Input::Initialization:: *)
MergeBifurcationData[b1_,b2_]:=
Module[{BPEqual},
BPEqual[{},{}]:=True;
BPEqual[{},bp2_]:=False;
BPEqual[bp1_,{}]:=False;
BPEqual[bp1_,bp2_]:=BPType[bp1]===BPType[bp2] &&EqualPoint[BPPoint[bp1],BPPoint[bp2]];
{b1[[1]]\[Union]b2[[1]],Union[b1[[2]],b2[[2]],SameTest->BPEqual]}]


(* ::Input::Initialization:: *)
Options[FollowLimitCycleBranch]=
{MaxStepSize->Automatic,MinStepSize->Automatic};


(* ::Input::Initialization:: *)
FollowLimitCycleBranch[lc_LimitSet,\[Lambda]_,opts___]:=
Module[{ds=LSDynamicalSystem[lc],\[Lambda]val,i\[Lambda],\[Lambda]Min,\[Lambda]Max,MaxStep,MinStep,LCBL={},LCBR={}},
\[Lambda]val=\[Lambda]/.DSParameterSubsts[ds];
i\[Lambda]=MyPosition[\[Lambda],DSParameters[ds]];
\[Lambda]Min=DS\[Lambda]Mins[ds][[i\[Lambda]]];\[Lambda]Max=DS\[Lambda]Maxs[ds][[i\[Lambda]]];
MaxStep=MaxStepSize/.{opts}/.Options[FollowLimitCycleBranch];
MinStep=MinStepSize/.{opts}/.Options[FollowLimitCycleBranch];
If[MaxStep===Automatic,MaxStep=(\[Lambda]Max-\[Lambda]Min)/25];
If[MinStep===Automatic,MinStep=MaxStep/100];
If[\[Lambda]val>\[Lambda]Min,LCBL=FollowLCBranchAux[lc,\[Lambda],-MaxStep,-MinStep]];
If[\[Lambda]val<\[Lambda]Max,LCBR=FollowLCBranchAux[lc,\[Lambda],MaxStep,MinStep]];
Join[Reverse[LCBL],LCBR]]


(* ::Input::Initialization:: *)
FollowLCBranchAux[lc_LimitSet,\[Lambda]_,MaxStep_,MinStep_]:=
Module[{ds=LSDynamicalSystem[lc],LC,LCB={lc},P,\[Lambda]start,\[CapitalDelta]\[Lambda],i\[Lambda],\[Lambda]Min,\[Lambda]Max,LC1,LC2,\[Lambda]1,\[Lambda]2,\[Lambda]Next,T1,T2,m,b,PredT,P1,P2,PredY0s},
\[Lambda]start=\[Lambda]/.DSParameterSubsts[LSDynamicalSystem[lc]];
\[CapitalDelta]\[Lambda]=MaxStep;
\[Lambda]start=\[Lambda]start+\[CapitalDelta]\[Lambda];
i\[Lambda]=MyPosition[\[Lambda],DSParameters[ds]];
\[Lambda]Min=DS\[Lambda]Mins[ds][[i\[Lambda]]];\[Lambda]Max=DS\[Lambda]Maxs[ds][[i\[Lambda]]];
(* Attempt to take the first step *)
LC=FindLimitCycle[ds/.\[Lambda]->\[Lambda]start,LSPoint[lc],LCPeriod[lc]];
If[!LC===Null,
PrependTo[LCB,LC],
Print["Unable to initiate limit cycle branch following due to a convergence failure"];Return[LCB]];
(* Follow the limit cycle branch as far as possible *)
For[P=\[Lambda]start+\[CapitalDelta]\[Lambda],\[Lambda]Min<=P<=\[Lambda]Max,P+=\[CapitalDelta]\[Lambda],
(* Extract the relevant info from the last two limit cycles in the branch *)
LC2=First[LCB];
LC1=LCB[[2]];
\[Lambda]1=\[Lambda]/.DSParameterSubsts[LSDynamicalSystem[LC1]];
\[Lambda]2=\[Lambda]/.DSParameterSubsts[LSDynamicalSystem[LC2]];
(* Predict the period of the next limit cycle in the branch *)
T1=LCPeriod[LC1];T2=LCPeriod[LC2];
m=(T2-T1)/(\[Lambda]2-\[Lambda]1);b=T1-m \[Lambda]1;
PredT=m P+b;
(* Predict the starting point of the next limit cycle in the branch *)
P1=LSPoint[LC1];P2=LSPoint[LC2];
PredY0s=(P-\[Lambda]1)/(\[Lambda]2-\[Lambda]1) (P2-P1)+P1;
(* Try to find the next limit cycle *)
LC=FindLimitCycle[ds/.\[Lambda]->P,PredY0s,PredT];
(* Did we succeed? *)
If[!LC===Null,
(* If so, add it to the branch and continue *)
PrependTo[LCB,LC],
(* If not, decrease step size and try again until min step, then punt *)
If[Abs[\[CapitalDelta]\[Lambda]/2]>Abs[MinStep],
P=P-\[CapitalDelta]\[Lambda];\[CapitalDelta]\[Lambda]=\[CapitalDelta]\[Lambda]/2,
Return[Reverse[LCB]]]]];
Reverse[LCB]]


(* ::Input::Initialization:: *)
Options[DisplayBifurcationDiagram]=
{EquilibriumBranchStyle->{Thickness[0.004]},BifurcationPointStyle->{PointSize[0.02]},
StateVariables->Automatic,LimitCycleBranches->{},BifurcationData->{{},{}},
(* EquilibriumPoints options *)
Tries->100,MaxIterations->100,AccuracyGoal->Automatic,WorkingPrecision->$MachinePrecision,
(* EquilibriumBranches options *)
InteriorPoints->{},InteriorGrid->0,
NeutralSaddles->False,
StartingStepSize->Automatic,MinStepSize->Automatic,MaxStepSize->Automatic,MaxSteps->250,SwitchBranches->True,MaxBend->10,
(* Graphics options *)
AspectRatio->Automatic,Axes->Automatic,AxesLabel->Automatic,AxesStyle->Automatic,Epilog->{},Frame->Automatic,FrameLabel->Automatic,FrameStyle->Automatic,FrameTicks->Automatic,GridLines->None,PlotLabel->None,PlotRange->Automatic,Prolog->{},Ticks->Automatic,DisplayFunction:>$DisplayFunction,PlotRangeClipping->True,
(* Additional Graphics3D options *)
Boxed->True,BoxRatios->{2,1,1},BoxStyle->{Thickness[0.001],GrayLevel[0.7]},ViewPoint->{1.2,-2.4,2.0}};


(* ::Input::Initialization:: *)
DisplayBifurcationDiagram[ds_DynamicalSystem,\[Lambda]_?SymbolQ,opts___]:=DisplayBifurcationDiagram[EquilibriumBranches[ds,\[Lambda],Sequence@@FilterRules[Flatten[{opts}],Options[EquilibriumBranches]]],opts]


(* ::Input::Initialization:: *)
DisplayBifurcationDiagram[EBs_List,opts___]:=Module[{Opts,G2Opts,G3Opts,BRs,BFs,BR1,ds,n,\[Lambda],i\[Lambda],\[Lambda]Val,SVs,BadSVs,Ys,is,iis,PR,EBStyle,BPStyle,LCBs,AX,FR,ALabels,FLabels,AR,EBGs,BPGs},CheckOptions[DisplayBifurcationDiagram,opts];Opts=Sequence@@Join[{opts},Options[DisplayBifurcationDiagram]];G2Opts=Sequence@@FilterRules[Flatten[{Opts}],Options[Graphics]];G3Opts=Sequence@@FilterRules[Flatten[{Opts}],Options[Graphics3D]];Opts={Opts};{BRs,BFs}=MergeBifurcationData[EBs,BifurcationData/. Opts];If[BRs==={},Return[Show[Graphics[{}],FrameLabel->None,AxesLabel->None,G2Opts]]];BR1=First[BRs];ds=EBDynamicalSystem[BR1];n=DSDimension[ds];\[Lambda]=EBParameter[BR1];SVs=StateVariables/. Opts;If[SVs==Automatic,If[n==2,SVs=DSStateVariables[ds],SVs={First[DSStateVariables[ds]]}]];BadSVs=Complement[SVs,DSStateVariables[ds]];If[BadSVs=!={},Print["Invalid state variables ",BadSVs," for ",ds];Return[Show[Graphics[{}],FrameLabel->None,AxesLabel->None,G2Opts]]];Ys=DSStateVariables[ds];is=(MyPosition[#1,Ys]&)/@SVs;iis=Join[{n+1},is];n=Length[iis];PR=PlotRange/. Opts;
i\[Lambda]=MyPosition[\[Lambda],DSParameters[ds]];
If[PR===Automatic,PR=Join[{{DS\[Lambda]Mins[ds][[i\[Lambda]]],DS\[Lambda]Maxs[ds][[i\[Lambda]]]}},Table[All,{n-1}]]];
If[PR===ParameterStateSpace,PR=Join[{{DS\[Lambda]Mins[ds][[i\[Lambda]]],DS\[Lambda]Maxs[ds][[i\[Lambda]]]}},Thread[{DSYMins[ds],DSYMaxs[ds]}][[is]]]];
EBStyle=EquilibriumBranchStyle/. Opts;If[Head[EBStyle]=!=List,EBStyle={EBStyle}];BPStyle=BifurcationPointStyle/. Opts;If[Head[BPStyle]=!=List,BPStyle={BPStyle}];
LCBs=LimitCycleBranches/.Opts;
AX=Axes/. Opts;If[AX===Automatic,Which[n==2,AX=False,n==3,AX=True]];FR=Frame/. Opts;If[FR===Automatic,FR=True];ALabels=AxesLabel/. Opts;If[ALabels===Automatic,ALabels=Join[{\[Lambda]},SVs]];FLabels=FrameLabel/. Opts;If[FLabels===Automatic,FLabels=Join[{\[Lambda]},SVs]];AR=AspectRatio/. Opts;If[AR==Automatic&&n==2,AR=1/GoldenRatio];G2Opts=Join[{PlotRange->PR,Axes->AX,AxesLabel->ALabels,Frame->FR,FrameLabel->FLabels,AspectRatio->AR},{G2Opts}];G3Opts=Join[{PlotRange->PR,Axes->AX,AxesLabel->ALabels},{G3Opts}];EBGs=(MakeEBGraphics[#1,iis,EBStyle]&)/@BRs;BPGs=(MakeBPGraphics[#1,\[Lambda],is,BPStyle]&)/@BFs;
$BifurcationDiagramBPs=BFs;
Which[
n==2,Show[Graphics[{EBGs,BPGs,MakeLCBranchGraphics2[\[Lambda],SVs,#]&/@LCBs}],G2Opts],
n==3,Show[Graphics3D[{EBGs,BPGs,MakeLCBranchGraphics3[\[Lambda],SVs,#]&/@LCBs}],G3Opts]]]


(* ::Input::Initialization:: *)
MakeEBGraphics[b_,z_,s_]:=
With[{x=EBType[b],l=Map[#[[z]]&,EBPoints[b]]},
Which[
x===Stable,Join[{RGBColor[0,0,1]},s,{Line[l]}],
x===Unstable,Join[{RGBColor[1,0,0]},s,{Line[l]}],
x===Saddle,Join[{RGBColor[0,1,0]},s,{Line[l]}],
True,Join[{GrayLevel[0]},s,{Line[l]}]]]


(* ::Input::Initialization:: *)
MakeBPGraphics[b_,\[Lambda]_,z_,s_]:=
With[{p=Join[{\[Lambda]/.DSParameterSubsts[BPDynamicalSystem[b]]},BPPoint[b][[z]]],t=BPType[b]},
Point[Join[{\[Lambda]/.DSParameterSubsts[BPDynamicalSystem[b]]},p]];
Join[s,
{Which[
t===Branch,Text["B",p,{3,0}],
t===Fold,Text["F",p,{3,0}],
t===Hopf,Text["H",p,{3,0}],
t===NeutralSaddle,Text["N",p,{3,0}],
True,Text["?",p,{3,0}]],
Point[p]}]]


(* ::Input::Initialization:: *)
MakeLCBranchGraphics2[\[Lambda]_,SVs_,LCB_]:=MakeLCGraphics2[\[Lambda],SVs,#]&/@LCB;

MakeLCGraphics2[\[Lambda]_,SVs_,LC_]:=
With[{ds=LSDynamicalSystem[LC]},
With[{\[Lambda]val=\[Lambda]/.DSParameterSubsts[ds],SVi=MyPosition[SVs[[1]],DSStateVariables[ds]]},
Module[{LCTraj=TrajectorySegment[LCTrajectory[LC],LCPeriod[LC]],LCMin,LCMax},
LCMin=Min[#[[SVi]]&/@LCTraj];
LCMax=Max[#[[SVi]]&/@LCTraj];
{EPColorFromStability[LSStability[LC]],Line[{{\[Lambda]val,LCMin},{\[Lambda]val,LCMax}}]}]]]


(* ::Input::Initialization:: *)
MakeLCBranchGraphics3[\[Lambda]_,SVs_,LCB_]:=MakeLCGraphics3[\[Lambda],SVs,#]&/@LCB;

MakeLCGraphics3[\[Lambda]_,SVs_,LC_]:=
With[{ds=LSDynamicalSystem[LC]},
With[{Ys=DSStateVariables[ds]},
With[{\[Lambda]val=\[Lambda]/.DSParameterSubsts[ds],SV1i=MyPosition[SVs[[1]],Ys],SV2i=MyPosition[SVs[[2]],Ys]},
Module[{LCTraj=TrajectorySegment[LCTrajectory[LC],LCPeriod[LC]]},
{EPColorFromStability[LSStability[LC]],
Line[{\[Lambda]val,#[[SV1i]],#[[SV2i]]}&/@LCTraj]}]]]]


(* ::Input::Initialization:: *)
Options[FollowBifurcationBranch]:=
{NeutralSaddles->False,StartingStepSize->Automatic,MinStepSize->Automatic,MaxStepSize->Automatic,MaxSteps->250,SwitchBranches->True,MaxBend->10,
MaxIterations->100,AccuracyGoal->Automatic,WorkingPrecision->$MachinePrecision}


(* ::Input::Initialization:: *)
FollowBifurcationBranch[bp_BifurcationPoint,{\[Lambda]1_?SymbolQ,\[Lambda]2_?SymbolQ},opts___?OptionQ]:=Module[{ds,OldPSubs,fps,Opts,NSaddles,FSBOpts,i\[Lambda]1,i\[Lambda]2,PSubs,\[Lambda]1Start,\[Lambda]2Start,Ys,YMins,YMaxs,\[Phi]1,\[Phi]2,f,TestExprs={},VerifyExprs={},Fs,BPT,BRs,SPs},
ds=BPDynamicalSystem[bp];
\[Lambda]1Start=\[Lambda]1/. DSParameterSubsts[ds];
\[Lambda]2Start=\[Lambda]2/. DSParameterSubsts[ds];OldPSubs=DSParameterSubsts[ds];ds=DSClearParameters[ds,{\[Lambda]1,\[Lambda]2}];
fps=DSFreeParameters[ds];If[Length[fps]>2,Print["Too many free parameters for FollowBifurcationBranch: ",fps];Return[{{},{}}]];CheckOptions[FollowBifurcationBranch,opts];Opts={opts};NSaddles=NeutralSaddles/. Opts/. Options[FollowEquilibriumBranch];FSBOpts=Sequence@@FilterRules[Flatten[{Sequence@@Join[Opts,Options[FollowBifurcationBranch]]}],Options[FollowSolutionBranch]];PSubs=DSParameterSubsts[ds];Ys=Join[DSStateVariables[ds],{\[Lambda]1,\[Lambda]2}];
YIs=Join[BPPoint[bp],{\[Lambda]1Start,\[Lambda]2Start}];
i\[Lambda]1=MyPosition[\[Lambda]1,DSParameters[ds]];
i\[Lambda]2=MyPosition[\[Lambda]2,DSParameters[ds]];YMins=Join[DSYMins[ds],{DS\[Lambda]Mins[ds][[i\[Lambda]1]],DS\[Lambda]Mins[ds][[i\[Lambda]2]]}];YMaxs=Join[DSYMaxs[ds],{DS\[Lambda]Maxs[ds][[i\[Lambda]1]],DS\[Lambda]Maxs[ds][[i\[Lambda]2]]}];
If[DS\[Phi]1[ds]===Numerical,
\[Phi]1=NDet[J];\[Phi]2=NDet[2 J\[CircleDot]IdentityMatrix[Length[DSStateVariables[ds]]]],
\[Phi]1=DS\[Phi]1[ds]/. PSubs;\[Phi]2=DS\[Phi]2[ds]/. PSubs];
BPT=BPType[bp];
Which[
BPT===Fold,f=\[Phi]1;If[n>1,TestExprs={\[Phi]2};VerifyExprs={SomeQ[PureImaginaryQ,NEigenvalues[DSJacobian[ds]]]}],
BPT===Branch,f=\[Phi]1;If[n>1,TestExprs={\[Phi]2};VerifyExprs={}],
BPT===Hopf||BPType[bp]===NeutralSaddle,f=\[Phi]2;TestExprs={\[Phi]1};VerifyExprs={},
True,Print["Unknown bifurcation type: ",BPT];Return[{{},{}}]];Fs=Append[DSFunctions[ds],f]/. PSubs;{BRs,SPs}=FollowSolutionBranch[Fs,Thread[{Ys,YIs,YMins,YMaxs}],TestExpressions->TestExprs,VerificationExpressions->VerifyExprs,FSBOpts];If[BPT===Branch,BPT=Fold];BRs=(MakeBifurcationBranchObject[ds,BPT,PSubs,{\[Lambda]1,\[Lambda]2},#1]&)/@BRs;If[!NSaddles,BRs=Select[BRs,BBType[#1]=!=NeutralSaddle&]];SPs=(MakeCodim2Object[ds,{\[Lambda]1,\[Lambda]2},#1]&)/@SPs;
MergeChartData[{{},{}},{BRs,SPs}]]


(* ::Input::Initialization:: *)
MakeBifurcationBranchObject[ds_,type_,PSubs_,\[Lambda]s_,P_]:=
Module[{tp=type},
Which[
tp===Hopf&&!TrueHopfBranch[ds,PSubs,\[Lambda]s,P],tp=NeutralSaddle,
tp===NeutralSaddle&&TrueHopfBranch[ds,PSubs,\[Lambda]s,P],tp=Hopf];
BifurcationBranch[ds,tp,\[Lambda]s,P]]


(* ::Input::Initialization:: *)
MakeCodim2Object[ds_,\[Lambda]s_,P_]:=
Module[{Ys=DSStateVariables[ds],PSubs=DSParameterSubsts[ds],EVs,type,nrealzero,npureimag},
EVs=Eigenvalues[DSJacobian[ds]/.PSubs/.Thread[Join[Ys,\[Lambda]s]->P]];
nrealzero=Length[Select[EVs,(#\[TildeTilde] 0)&]];
npureimag=Length[Select[EVs,(Re[#]\[TildeTilde] 0)&&!(Im[#]\[TildeTilde]0)&]];
Which[
False,type=Cusp,
False,type=GeneralizedHopf,
nrealzero==2,type=BogdanovTakens,
nrealzero==1&&npureimag==2,type=FoldHopf,
npureimag==4,type=HopfHopf,
True,type=Unknown];
Chop[Codim2Point[ds/.{\[Lambda]s[[1]]->P[[Length[P]-1]],\[Lambda]s[[2]]->Last[P]},type,Drop[P,-2]],$EqualityTolerance/100]]


(* ::Input::Initialization:: *)
TrueHopfBranch[ds_,PSubs_,\[Lambda]s_,B_]:=
Module[{PSs},
PSs=Join[PSubs,Thread[Join[DSStateVariables[ds],\[Lambda]s]->B[[Round[Length[B]/2]]]]];
SomeQ[PureImaginaryQ,Eigenvalues[DSJacobian[ds]/.PSs]]]


(* ::Input::Initialization:: *)
Options[BifurcationBranches]=
{InteriorPoints->{},InteriorGrid->0,
NeutralSaddles->False,
StartingStepSize->Automatic,MinStepSize->Automatic,MaxStepSize->Automatic,MaxSteps->1000,SwitchBranches->True,MaxBend->10,
Tries->50,
MaxIterations->100,AccuracyGoal->Automatic,WorkingPrecision->$MachinePrecision};


(* ::Input::Initialization:: *)
BifurcationBranches[dds_DynamicalSystem,{\[Lambda]1_?SymbolQ,\[Lambda]2_?SymbolQ},opts___]:=Module[{ds,fps,Opts,EPOptions,FEBOptions,FBBOptions,IntPnts,PSubs,i\[Lambda]1,i\[Lambda]2,\[Lambda]1Min,\[Lambda]1Max,\[Lambda]2Min,\[Lambda]2Max,\[Lambda]Vals,LLEPs,LREPs,ULEPs,UREPs,LLEBsRight,LLEBsUp,LREBsLeft,LREBsUp,ULEBsRight,ULEBsDown,UREBsLeft,UREBsDown,EPs,EBs,EB1s,C2Bs,i,T1,KnownC2Ps,UnknownC2Ps,IntGrd},ds=DSClearParameters[dds,{\[Lambda]1,\[Lambda]2}];fps=DSFreeParameters[ds];If[Length[fps]>2,Print["Too many free parameters for BifurcationBranches: ",fps];Return[{{},{}}]];CheckOptions[BifurcationBranches,opts];Opts={opts};EPOptions=Sequence@@FilterRules[Flatten[{Sequence@@Join[Opts,Options[BifurcationBranches]]}],Options[EquilibriumPoints]];FEBOptions=Sequence@@FilterRules[Flatten[{Sequence@@DeleteCases[Join[Opts,Options[BifurcationBranches]],(InteriorPoints->_)|(InteriorGrid->_)]}],Options[FollowEquilibriumBranch]];FBBOptions=Sequence@@FilterRules[Flatten[{Sequence@@Join[Opts,Options[BifurcationBranches]]}],Options[FollowBifurcationBranch]];IntPnts=InteriorPoints/. Opts/. Options[BifurcationBranches];IntGrd=InteriorGrid/. Opts/. Options[BifurcationBranches];If[NumericQ[IntGrd],IntGrd={IntGrd,IntGrd}];PSubs=DSParameterSubsts[ds];i\[Lambda]1=MyPosition[\[Lambda]1,DSParameters[ds]];\[Lambda]1Min=DS\[Lambda]Mins[ds][[i\[Lambda]1]];\[Lambda]1Max=DS\[Lambda]Maxs[ds][[i\[Lambda]1]];i\[Lambda]2=MyPosition[\[Lambda]2,DSParameters[ds]];\[Lambda]2Min=DS\[Lambda]Mins[ds][[i\[Lambda]2]];\[Lambda]2Max=DS\[Lambda]Maxs[ds][[i\[Lambda]2]];With[{\[Lambda]1Step=(\[Lambda]1Max-\[Lambda]1Min)/(IntGrd[[1]]+1),\[Lambda]2Step=(\[Lambda]2Max-\[Lambda]2Min)/(IntGrd[[2]]+1)},IntPnts=Join[IntPnts,Flatten[Table[{x,y},{x,\[Lambda]1Min+\[Lambda]1Step,\[Lambda]1Max-\[Lambda]1Step,\[Lambda]1Step},{y,\[Lambda]2Min+\[Lambda]2Step,\[Lambda]2Max-\[Lambda]2Step,\[Lambda]2Step}],1]]];LLEPs=EquilibriumPoints[ds/. {\[Lambda]1->\[Lambda]1Min,\[Lambda]2->\[Lambda]2Min},EPOptions];LREPs=EquilibriumPoints[ds/. {\[Lambda]1->\[Lambda]1Max,\[Lambda]2->\[Lambda]2Min},EPOptions];ULEPs=EquilibriumPoints[ds/. {\[Lambda]1->\[Lambda]1Min,\[Lambda]2->\[Lambda]2Max},EPOptions];UREPs=EquilibriumPoints[ds/. {\[Lambda]1->\[Lambda]1Max,\[Lambda]2->\[Lambda]2Max},EPOptions];LLEBsRight={{},{}};EPs=LLEPs;
For[i=1,i<=Length[EPs],i++,If[NewEquilibriumBranch[EPs[[i]],LLEBsRight[[1]],\[Lambda]1Min],LLEBsRight=MergeBifurcationData[LLEBsRight,FollowEquilibriumBranch[EPs[[i]],\[Lambda]1,FEBOptions]]]];LLEBsUp={{},{}};EPs=LLEPs;For[i=1,i<=Length[EPs],i++,If[NewEquilibriumBranch[EPs[[i]],LLEBsUp[[1]],\[Lambda]2Min],LLEBsUp=MergeBifurcationData[LLEBsUp,FollowEquilibriumBranch[EPs[[i]],\[Lambda]2,FEBOptions]]]];LREBsLeft={{},{}};EPs=Select[LREPs,NewEquilibriumBranch[#1,LLEBsRight[[1]],\[Lambda]1Max]&];For[i=1,i<=Length[EPs],i++,If[NewEquilibriumBranch[EPs[[i]],LREBsLeft[[1]],\[Lambda]1Max],LREBsLeft=MergeBifurcationData[LREBsLeft,FollowEquilibriumBranch[EPs[[i]],\[Lambda]1,FEBOptions]]]];LREBsUp={{},{}};EPs=LREPs;For[i=1,i<=Length[EPs],i++,If[NewEquilibriumBranch[EPs[[i]],LREBsUp[[1]],\[Lambda]2Min],LREBsUp=MergeBifurcationData[LREBsUp,FollowEquilibriumBranch[EPs[[i]],\[Lambda]2,FEBOptions]]]];ULEBsRight={{},{}};EPs=ULEPs;For[i=1,i<=Length[EPs],i++,If[NewEquilibriumBranch[EPs[[i]],ULEBsRight[[1]],\[Lambda]1Min],ULEBsRight=MergeBifurcationData[ULEBsRight,FollowEquilibriumBranch[EPs[[i]],\[Lambda]1,FEBOptions]]]];ULEBsDown={{},{}};EPs=Select[ULEPs,NewEquilibriumBranch[#1,LLEBsUp[[1]],\[Lambda]2Max]&];For[i=1,i<=Length[EPs],i++,If[NewEquilibriumBranch[EPs[[i]],ULEBsDown[[1]],\[Lambda]2Max],ULEBsDown=MergeBifurcationData[ULEBsDown,FollowEquilibriumBranch[EPs[[i]],\[Lambda]2,FEBOptions]]]];UREBsLeft={{},{}};EPs=Select[UREPs,NewEquilibriumBranch[#1,ULEBsRight[[1]],\[Lambda]1Max]&];For[i=1,i<=Length[EPs],i++,If[NewEquilibriumBranch[EPs[[i]],UREBsLeft[[1]],\[Lambda]1Max],UREBsLeft=MergeBifurcationData[UREBsLeft,FollowEquilibriumBranch[EPs[[i]],\[Lambda]1,FEBOptions]]]];UREBsDown={{},{}};EPs=Select[UREPs,NewEquilibriumBranch[#1,LREBsUp[[1]],\[Lambda]2Max]&];For[i=1,i<=Length[EPs],i++,If[NewEquilibriumBranch[EPs[[i]],UREBsDown[[1]],\[Lambda]2Max],UREBsDown=MergeBifurcationData[UREBsDown,FollowEquilibriumBranch[EPs[[i]],\[Lambda]2,FEBOptions]]]];EBs=MergeBifurcationData[LLEBsRight,LLEBsUp];EBs=MergeBifurcationData[EBs,LREBsLeft];EBs=MergeBifurcationData[EBs,LREBsUp];EBs=MergeBifurcationData[EBs,ULEBsRight];EBs=MergeBifurcationData[EBs,ULEBsDown];EBs=MergeBifurcationData[EBs,UREBsLeft];EBs=MergeBifurcationData[EBs,UREBsDown];C2Bs={{},{}};
For[i=1,i<=Length[EBs[[2]]],i++,\[Lambda]Vals={\[Lambda]1,\[Lambda]2}/. DSParameterSubsts[BPDynamicalSystem[EBs[[2,i]]]];If[NewBifurcationBranch[EBs[[2,i]],C2Bs[[1]],\[Lambda]Vals],C2Bs=MergeChartData[C2Bs,FollowBifurcationBranch[EBs[[2,i]],{\[Lambda]1,\[Lambda]2},FBBOptions]]]];EBs={{},{}};For[i=1,i<=Length[IntPnts],i++,EPs=EquilibriumPoints[ds/. Thread[{\[Lambda]1,\[Lambda]2}->IntPnts[[i]]],EPOptions];
EB1s=(FollowEquilibriumBranch[#1,\[Lambda]1,FEBOptions]&)/@EPs;
EBs=Fold[MergeBifurcationData,EBs,EB1s];EB1s=(FollowEquilibriumBranch[#1,\[Lambda]2,FEBOptions]&)/@EPs;EBs=Fold[MergeBifurcationData,EBs,EB1s]];
T1=(FollowBifurcationBranch[#1,{\[Lambda]1,\[Lambda]2},FBBOptions]&)/@EBs[[2]];C2Bs=Fold[MergeChartData,C2Bs,T1];KnownC2Ps=Select[C2Bs[[2]],C2PType[#1]=!=Unknown&];UnknownC2Ps=Select[C2Bs[[2]],C2PType[#1]===Unknown&];UnknownC2Ps=Select[UnknownC2Ps,!Codim2PointMember[#1,KnownC2Ps]&];
{C2Bs[[1]],Join[KnownC2Ps,UnknownC2Ps]}]


(* ::Input::Initialization:: *)
NewBifurcationBranch[Bif_,C2Bs_,\[Lambda]s_]:=
Module[{BifPt=Join[BPPoint[Bif],\[Lambda]s]},
!SomeQ[(EqualPoint[BifPt,First[BBPoints[#]]]\[Or]EqualPoint[BifPt,Last[BBPoints[#]]])&,C2Bs]]


(* ::Input::Initialization:: *)
Codim2PointMember[c2p_,c2ps_]:=
SomeQ[(EqualPoint[C2PPoint[c2p],C2PPoint[#]])&,c2ps]


(* ::Input::Initialization:: *)
MergeChartData[b1_,b2_]:=
Module[{C2PEqual},
C2PEqual[{},{}]:=True;
C2PEqual[{},c2p2_]:=False;
C2PEqual[c2p1_,{}]:=False;
C2PEqual[c2p1_,c2p2_]:=
C2PType[c2p1]===C2PType[c2p2]&&EqualPoint[C2PPoint[c2p1],C2PPoint[c2p2]];
{b1[[1]]\[Union]b2[[1]],Union[b1[[2]],b2[[2]],SameTest->C2PEqual]}]


(* ::Input::Initialization:: *)
Options[DisplayParameterChart]=
{BifurcationBranchStyle->{Thickness[0.004]},Codim2PointStyle->{PointSize[0.02]},
(* EquilibriumPoints options *)
Tries->50,MaxIterations->100,AccuracyGoal->Automatic,WorkingPrecision->$MachinePrecision,
(* EquilibriumBranches and BifurcationBranches options *)
InteriorPoints->{},InteriorGrid->0,
NeutralSaddles->False,
StartingStepSize->Automatic,MinStepSize->Automatic,MaxStepSize->Automatic,MaxSteps->250,SwitchBranches->True,MaxBend->10,
(* Graphics options *)
AspectRatio->1,Axes->False,AxesLabel->None,AxesStyle->Automatic,Epilog->{},Frame->True,FrameLabel->Automatic,FrameStyle->Automatic,FrameTicks->Automatic,GridLines->None,PlotLabel->None,PlotRange->ParameterSpace,Prolog->{},Ticks->Automatic,
PlotRangeClipping->True,DisplayFunction:>$DisplayFunction};


(* ::Input::Initialization:: *)
DisplayParameterChart[ds_DynamicalSystem,\[Lambda]s_,opts___]:=DisplayParameterChart[BifurcationBranches[ds,\[Lambda]s,Sequence@@FilterRules[Flatten[{opts}],Options[BifurcationBranches]]],opts]


(* ::Input::Initialization:: *)
DisplayParameterChart[BBs_List,opts___]:=Module[{Opts,G2Opts,BBRs,C2Ps,BBR1,ds,\[Lambda]1,\[Lambda]2,PR,BBStyle,C2PStyle,ALabels,FLabels,BBGs,C2PGs},
CheckOptions[DisplayParameterChart,opts];Opts=Sequence@@Join[{opts},Options[DisplayParameterChart]];G2Opts=Sequence@@FilterRules[Flatten[{Opts}],Options[Graphics]];Opts={Opts};{BBRs,C2Ps}=BBs;If[BBRs==={},Return[Show[Graphics[{}],FrameLabel->None,AxesLabel->None,G2Opts]]];BBR1=First[BBRs];ds=BBDynamicalSystem[BBR1];{\[Lambda]1,\[Lambda]2}=BBParameters[BBR1];PR=PlotRange/. Opts;If[PR===ParameterSpace,With[{i1=MyPosition[\[Lambda]1,DSParameters[ds]],i2=MyPosition[\[Lambda]2,DSParameters[ds]]},PR={{DS\[Lambda]Mins[ds][[i1]],DS\[Lambda]Maxs[ds][[i1]]},{DS\[Lambda]Mins[ds][[i2]],DS\[Lambda]Maxs[ds][[i2]]}}]];BBStyle=BifurcationBranchStyle/. Opts;If[Head[BBStyle]=!=List,BBStyle={BBStyle}];C2PStyle=Codim2PointStyle/. Opts;If[Head[C2PStyle]=!=List,C2PStyle={C2PStyle}];ALabels=AxesLabel/. Opts;If[ALabels===Automatic,ALabels={\[Lambda]1,\[Lambda]2}];FLabels=FrameLabel/. Opts;If[FLabels===Automatic,FLabels={\[Lambda]1,\[Lambda]2}];G2Opts=Join[{PlotRange->PR,AxesLabel->ALabels,FrameLabel->FLabels},{G2Opts}];BBGs=(MakeBBGraphics[#1,BBStyle]&)/@BBRs;C2PGs=(MakeC2PGraphics[#1,{\[Lambda]1,\[Lambda]2},C2PStyle]&)/@C2Ps;
$ParameterChartCodim2BPs=C2Ps;
Show[Graphics[{BBGs,C2PGs}],G2Opts]]


(* ::Input::Initialization:: *)
MakeBBGraphics[bb_,s_]:=
With[{type=BBType[bb],l=Map[Take[#,-2]&,BBPoints[bb]]},
Which[
type===Fold,Join[s,{Line[l]}],
type===Hopf,Join[{GrayLevel[0.6]},s,{Line[l]}],
type===NeutralSaddle,Join[{Dashing[{0.02,0.02}]},s,{Line[l]}],
True,Print["Unknown bifurcation branch type: ",type]]]


(* ::Input::Initialization:: *)
MakeC2PGraphics[c_,\[Lambda]s_,s_]:=
With[{p=\[Lambda]s/.DSParameterSubsts[C2PDynamicalSystem[c]],t=C2PType[c]},
Join[s,
{Which[
t===Cusp,Text["C",p,{1.5,0}],
t===GeneralizedHopf,Text["GH",p,{1.5,0}],
t===BogdanovTakens,Text["BT",p,{1.5,0}],
t===FoldHopf,Text["FH",p,{1.5,0}],
t===HopfHopf,Text["HH",p,{1.5,0}],
True,Text["?",p,{2.5,0}]],
Point[p]}]]


(* ::Input::Initialization:: *)
End[]


(* ::Input::Initialization:: *)
EndPackage[]
